<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>cvc5.SkolemId</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="cvc5.SkolemId";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">cvc5</span>.<span class="name">SkolemId</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/SkolemId.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init.html">Init</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-cvc5.SkolemId" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#cvc5.SkolemId"><span class="name">cvc5</span>.<span class="name">SkolemId</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instInhabitedSkolemId"><span class="name">cvc5</span>.<span class="name">instInhabitedSkolemId</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instReprSkolemId"><span class="name">cvc5</span>.<span class="name">instReprSkolemId</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instBEqSkolemId"><span class="name">cvc5</span>.<span class="name">instBEqSkolemId</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instDecidableEqSkolemId"><span class="name">cvc5</span>.<span class="name">instDecidableEqSkolemId</span></a></div></nav><main>
<div class="decl" id="cvc5.SkolemId"><div class="inductive"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/SkolemId.lean#L10-L781">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/SkolemId.html#cvc5.SkolemId"><span class="name">cvc5</span>.<span class="name">SkolemId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The kind of a cvc5 skolem. A skolem is a (family of) internal functions or
constants that are introduced by cvc5. These symbols are treated as
uninterpreted internally. We track their definition for the purposes of
formal bookkeeping for the user of features like proofs, lemma exporting,
simplification and so on.</p><p>A skolem has an identifier and a set of &quot;skolem indices&quot;. The skolem
indices are <em>not</em> children of the skolem function, but rather should
be seen as the way of distinguishing skolems from the same family.</p><p>For example, the family of &quot;array diff&quot; skolems <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.ARRAY_DEQ_DIFF">ARRAY_DEQ_DIFF</a></code> witness
the disequality between two arrays, which are its skolem indices.</p><p>Say that skolem k witnesses the disequality between two arrays A and B
of type <code>(Array <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code>. Then, k is a term whose skolem identifier is
<code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.ARRAY_DEQ_DIFF">ARRAY_DEQ_DIFF</a></code>, skolem indices are A and B, and whose type is <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>.</p><p>Note the type of k is not <code>(-&gt; (Array <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int) (Array <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int) Int)</code>.
Intuitively, this is due to the fact that cvc5 does not reason about array
diff skolem as a function symbol. Furthermore, the array diff skolem that
witnesses the disequality of arrays C and D is a separate skolem function k2
from this family, also of type <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, where internally k2 has no relation
to k apart from having the same skolem identifier.</p><p>In contrast, cvc5 reasons about division-by-zero using a single skolem
function whose identifier is <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.DIV_BY_ZERO">DIV_BY_ZERO</a></code>. This means its skolem indices
are empty and the skolem has a functional type <code>(-&gt; Real Real)</code>.</p><p>\internal</p><ul class="constructors"><li class="constructor" id="cvc5.SkolemId.INTERNAL">INTERNAL : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The identifier of the skolem is not exported. These skolems should not
appear in any user-level API calls.</p></div></li><li class="constructor" id="cvc5.SkolemId.PURIFY">PURIFY : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The purification skolem for a term. This is a variable that is semantically
equivalent to the indexed term t.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The term t that this skolem purifies.</li>
</ul>
</li>
<li>Sort: The sort of t.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.GROUND_TERM">GROUND_TERM : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An arbitrary ground term of a given sort.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> A term that represents the sort of the term.</li>
</ul>
</li>
<li>Sort: The sort given by the index.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.ARRAY_DEQ_DIFF">ARRAY_DEQ_DIFF : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The array diff skolem, which is the witness k for the inference
<code>(=&gt; (not (= A B)) (not (= (select A k) (select B k))))</code>.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The first array of sort <code>(Array T1 T2)</code>.</li>
<li><code>2:</code> The second array of sort <code>(Array T1 T2)</code>.</li>
</ul>
</li>
<li>Sort: <code>T1</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BV_EMPTY">BV_EMPTY : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The empty bitvector.</p><ul>
<li>Number of skolem indices: <code>0</code></li>
<li>Type: <code>(_ <a href=".././Init/Prelude.html#BitVec">BitVec</a> 0)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.DIV_BY_ZERO">DIV_BY_ZERO : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The function for division by zero. This is semantically equivalent to the
SMT-LIB term <code>(lambda ((x Real)) (/ x 0.0))</code>.</p><ul>
<li>Number of skolem indices: <code>0</code></li>
<li>Sort: <code>(-&gt; Real Real)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.INT_DIV_BY_ZERO">INT_DIV_BY_ZERO : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The function for integer division by zero. This is semantically equivalent
to the SMT-LIB term <code>(lambda ((x Int)) (div x 0))</code>.</p><ul>
<li>Number of skolem indices: <code>0</code></li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.MOD_BY_ZERO">MOD_BY_ZERO : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The function for integer modulus by zero. This is semantically equivalent
to the SMT-LIB term <code>(lambda ((x Int)) (mod x 0))</code>.</p><ul>
<li>Number of skolem indices: <code>0</code></li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.TRANSCENDENTAL_PURIFY">TRANSCENDENTAL_PURIFY : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A function introduced to eliminate extended trancendental functions.
Transcendental functions like sqrt, arccos, arcsin, etc. are replaced
during processing with uninterpreted functions that are unique to
each function.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> A lambda corresponding to the function, e.g.,
<code>(lambda ((x Real)) (sqrt x))</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; Real Real)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.TRANSCENDENTAL_PURIFY_ARG">TRANSCENDENTAL_PURIFY_ARG : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Argument used to purify trancendental function app <code>(f x)</code>.
For <code>(sin x)</code>, this is a variable that is assumed to be in phase with
<code>x</code> that is between <code>-pi</code> and <code>pi</code>.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The application of a trancendental function.</li>
</ul>
</li>
<li>Sort: <code>Real</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.TRANSCENDENTAL_SINE_PHASE_SHIFT">TRANSCENDENTAL_SINE_PHASE_SHIFT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Argument used to reason about the phase shift of arguments to sine.
In particular, this is an integral rational indicating the number of times
:math:<code>2\pi</code> is added to a real value between :math:<code>-\pi</code> and :math:<code>\pi</code>
to obtain the value of argument to sine.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The argument to sine.</li>
</ul>
</li>
<li>Sort: <code>Real</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.ARITH_VTS_DELTA">ARITH_VTS_DELTA : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Used to reason about virtual term substitution. This term represents
an infinitesimal. This skolem is expected to appear in instantiations
and immediately be rewritten via virtual term substitution.</p><ul>
<li>Number of skolem indices: <code>0</code></li>
<li>Sort: <code>Real</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.ARITH_VTS_DELTA_FREE">ARITH_VTS_DELTA_FREE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Used to reason about virtual term substitution. This term represents
an infinitesimal. Unlike ARITH_VTS_DELTA, this skolem may appear in
lemmas.</p><ul>
<li>Number of skolem indices: <code>0</code></li>
<li>Sort: <code>Real</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.ARITH_VTS_INFINITY">ARITH_VTS_INFINITY : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Used to reason about virtual term substitution. This term represents
infinity.  This skolem is expected to appear in instantiations
and immediately be rewritten via virtual term substitution.</p><ul>
<li>Number of skolem indices: <code>0</code><ul>
<li><code>1:</code> A term that represents an arithmetic sort (Int or Real).</li>
</ul>
</li>
<li>Sort: The sort given by the index.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.ARITH_VTS_INFINITY_FREE">ARITH_VTS_INFINITY_FREE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Used to reason about virtual term substitution. This term represents
infinity. Unlike ARITH_VTS_INFINITY, this skolem may appear in
lemmas.</p><ul>
<li>Number of skolem indices: <code>0</code><ul>
<li><code>1:</code> A term that represents an arithmetic sort (Int or Real).</li>
</ul>
</li>
<li>Sort: The sort given by the index.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SHARED_SELECTOR">SHARED_SELECTOR : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A shared datatype selector, see Reynolds et. al. &quot;Datatypes with Shared
Selectors&quot;, IJCAR 2018. Represents a selector that can extract fields
of multiple constructors.</p><ul>
<li>Number of skolem indices: <code>3</code><ul>
<li><code>1:</code> A term that represents the datatype we are extracting from.</li>
<li><code>2:</code> A term that represents the sort of field we are extracting.</li>
<li><code>3:</code> An integer n such that this shared selector returns the n^th
subfield term of the given sort.</li>
</ul>
</li>
<li>Sort: A selector sort whose domain is given by first index,
and whose codomain is the given by the second index.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.HO_DEQ_DIFF">HO_DEQ_DIFF : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The higher-roder diff skolem, which is the witness k for the inference
<code>(=&gt; (not (= A B)) (not (= (A k1 ... kn) (B k1 ... kn))))</code>.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The first function of sort <code>(-&gt; T1 ... Tn T)</code>.</li>
<li><code>2:</code> The second function of sort <code>(-&gt; T1 ... Tn T)</code>.</li>
<li><code>3:</code> The argument index i.</li>
</ul>
</li>
<li>Sort: <code>Ti</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.QUANTIFIERS_SKOLEMIZE">QUANTIFIERS_SKOLEMIZE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The n^th skolem for the negation of universally quantified formula Q.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The quantified formula Q.</li>
<li><code>2:</code> The index of the variable in the binder of Q to skolemize.</li>
</ul>
</li>
<li>Sort: The type of the variable referenced by the second index.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.WITNESS_STRING_LENGTH">WITNESS_STRING_LENGTH : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A witness for a string or sequence of a given length. Skolems in this family can
be assumed to be distinct if their identifiers (given by their third index) are
distinct modulo :math:<code>A</code> to the power of their length (given by their second index),
where :math:<code>A</code> is the cardinality of the characters of their sort.</p><ul>
<li>Number of skolem indices: <code>3</code><ul>
<li><code>1:</code> A term that represents the sort of the term.</li>
<li><code>2:</code> The assumed length of this term, expected to be a non-negative integer.</li>
<li><code>3:</code> A numeral identifier.</li>
</ul>
</li>
<li>Sort: The sort given by the first index.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.WITNESS_INV_CONDITION">WITNESS_INV_CONDITION : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A witness for an invertibility condition.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> A formula of the form <code>(exists x. (x &lt;op&gt; s) &lt;rel&gt; t)</code>
or <code>(exists x. x &lt;rel&gt; t)</code>, where s and t are ground
(bitvector) terms.</li>
</ul>
</li>
<li>Sort: The sort of x is given by the formula in the first index.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_NUM_OCCUR">STRINGS_NUM_OCCUR : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An integer corresponding to the number of times a string occurs in another
string. This is used to reason about str.replace_all.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The first string.</li>
<li><code>2:</code> The second string.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_OCCUR_INDEX">STRINGS_OCCUR_INDEX : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A function k such that for x = 0...n, (k x) is the end
index of the x^th occurrence of a string b in string a, where n is the
number of occurrences of b in a, and <code>(= (k 0) 0)</code>. This is used to
reason about str.replace_all.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The first string.</li>
<li><code>2:</code> The second string.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_NUM_OCCUR_RE">STRINGS_NUM_OCCUR_RE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Analogous to STRINGS_NUM_OCCUR, but for regular expressions.
An integer corresponding to the number of times a regular expression can
be matched in a string.  This is used to reason about str.replace_all_re.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The string to match.</li>
<li><code>2:</code> The regular expression to find.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_OCCUR_INDEX_RE">STRINGS_OCCUR_INDEX_RE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Analogous to STRINGS_OCCUR_INDEX, but for regular expressions.
A function k such that for x = 0...n, (k x) is the end
index of the x^th occurrence of a regular expression R in string a, where
n is the number of occurrences of R in a, and <code>(= (k 0) 0)</code>. This is used
to reason about str.replace_all_re.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The string to match.</li>
<li><code>2:</code> The regular expression to find.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_OCCUR_LEN_RE">STRINGS_OCCUR_LEN_RE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A function k where for x = 0...n, <code>(k x)</code> is the length of
the x^th occurrence of R in a (excluding matches of empty strings) where R
is a regular expression, n is the number of occurrences of R in a, and
<code>(= (k 0) 0)</code>.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The string to match.</li>
<li><code>2:</code> The regular expression to find.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_DEQ_DIFF">STRINGS_DEQ_DIFF : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Difference index for string disequalities, such that k is the witness for
the inference
<code>(=&gt; (not (= a b)) (not (= (substr a k 1) (substr b k 1))))</code>
where note that <code>k</code> may be out of bounds for at most of a,b.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The first string.</li>
<li><code>2:</code> The second string.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_REPLACE_ALL_RESULT">STRINGS_REPLACE_ALL_RESULT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A function used to define intermediate results of str.replace_all and
str.replace_re_all applications. This denotes a function that denotes the
result of processing the string or sequence after processing the n^th
occurrence of string or match of the regular expression in the given
replace_all term.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The application of replace_all or replace_all_re.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> S)</code> where S is either <code><a href=".././Init/Prelude.html#String">String</a></code> or <code>(Seq T)</code> for
some <code>T</code>.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_ITOS_RESULT">STRINGS_ITOS_RESULT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A function used to define intermediate results of str.from_int
applications. This is a function k denoting the result
of processing the first n digits of the argument.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The argument to str.from_int.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_STOI_RESULT">STRINGS_STOI_RESULT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A function used to define intermediate results of str.from_int
applications. This is a function k of type <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> String)</code> denoting the
result of processing the first n characters of the argument.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The argument to str.to_int.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> String)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.STRINGS_STOI_NON_DIGIT">STRINGS_STOI_NON_DIGIT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A position containing a non-digit in a string, used when <code>(str.to_int a)</code>
is equal to -1. This is an integer that returns a position for which the
argument string is not a digit if one exists, or is unconstrained otherwise.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The argument to str.to_int.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.RE_FIRST_MATCH_PRE">RE_FIRST_MATCH_PRE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The next three skolems are used to decompose the match of a regular
expression in string.</p><p>For string a and regular expression R, this skolem is the prefix of
string a before the first, shortest match of R in a. Formally, if
<code>(str.in_re a (re.++ (re.* re.allchar) R (re.* re.allchar)))</code>, then
there exists strings k_pre, k_match, k_post such that:
<code>(= a (str.++ k_pre k_match k_post))</code> and
<code>(= (len k_pre) (indexof_re a R 0))</code> and
<code>(forall ((l Int)) (=&gt; (&lt; 0 l (len k_match)) (not (str.in_re (substr k_match 0 l) R))))</code> and
<code>(str.in_re k_match R)</code>
This skolem is k_pre, and the proceeding two skolems are k_match and
k_post.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The string.</li>
<li><code>2:</code> The regular expression to match.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Prelude.html#String">String</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.RE_FIRST_MATCH">RE_FIRST_MATCH : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>For string a and regular expression R, this skolem is the string that
the first, shortest match of R was matched to in a.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The string.</li>
<li><code>2:</code> The regular expression to match.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Prelude.html#String">String</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.RE_FIRST_MATCH_POST">RE_FIRST_MATCH_POST : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>For string a and regular expression <code>R</code>, this skolem is the remainder
of a after the first, shortest match of <code>R</code> in a.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The string.</li>
<li><code>2:</code> The regular expression to match.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Prelude.html#String">String</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.RE_UNFOLD_POS_COMPONENT">RE_UNFOLD_POS_COMPONENT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Regular expression unfold component: if <code>(str.in_re a R)</code>, where R is
<code>(re.++ R0 ... Rn)</code>, then the <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.RE_UNFOLD_POS_COMPONENT">RE_UNFOLD_POS_COMPONENT</a></code> for indices
(a,R,i) is a string ki such that <code>(= a (str.++ k0 ... kn))</code> and
<code>(str.in_re k0 R0)</code> for i = 0, ..., n.</p><ul>
<li>Number of skolem indices: <code>3</code><ul>
<li><code>1:</code> The string.</li>
<li><code>2:</code> The regular expression.</li>
<li><code>3:</code> The index of the skolem.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Prelude.html#String">String</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_CARD_COMBINE">BAGS_CARD_COMBINE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for bag.card operator:
To compute <code>(bag.card A)</code>, we need a function that
counts multiplicities of distinct elements. We call this function
combine of type Int -&gt; Int where:
combine(0) = 0.
combine(i) = m(elements(i), A) + combine(i-1) for 1 &lt;= i &lt;= n.
elements: a skolem function for (bag.fold f t A).
See <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS">BAGS_DISTINCT_ELEMENTS</a></code>.
n: is the number of distinct elements in A.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the bag argument A.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS_UNION_DISJOINT">BAGS_DISTINCT_ELEMENTS_UNION_DISJOINT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for the union of distinct elements
in a bag (Bag T). To compute operators like bag.card,
we need a function for distinct elements in A of type (-&gt; Int T)
(see <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS">BAGS_DISTINCT_ELEMENTS</a></code>).
We also need to restrict the range [1, n] to only elements in the bag
as follows:
unionDisjoint(0) = bag.empty.
unionDisjoint(i) = disjoint union of {&lt;elements(i), m(elements(i), A)&gt;}
and unionDisjoint(i-1).
unionDisjoint(n) = A.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the bag argument A of type (Bag T).</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> (Bag T))</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_FOLD_CARD">BAGS_FOLD_CARD : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for bag.fold operator:
To compute <code>(bag.fold f t A)</code>, we need to guess the cardinality n of
bag A using a skolem function with <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_FOLD_CARD">BAGS_FOLD_CARD</a></code> id.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the bag argument A.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_FOLD_COMBINE">BAGS_FOLD_COMBINE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for bag.fold operator:
To compute <code>(bag.fold f t A)</code>, we need a function that
accumulates intermidiate values. We call this function
combine of type Int -&gt; T2 where:
combine(0) = t
combine(i) = f(elements(i), combine(i - 1)) for 1 &lt;= i &lt;= n.
elements: a skolem function for (bag.fold f t A)
see <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_FOLD_ELEMENTS">BAGS_FOLD_ELEMENTS</a></code>.
n: is the cardinality of A.
T2: is the type of initial value t.</p><ul>
<li>Number of skolem indices: <code>3</code><ul>
<li><code>1:</code> the function f of type <code>(-&gt; T1 T2)</code>.</li>
<li><code>2:</code> the initial value t of type <code>T2</code>.</li>
<li><code>3:</code> the bag argument A of type <code>(Bag T1)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> T2)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_FOLD_ELEMENTS">BAGS_FOLD_ELEMENTS : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for bag.fold operator:
To compute <code>(bag.fold f t A)</code>, we need a function for
elements of A. We call this function
elements of type <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> T1)</code> where T1 is the type of
elements of A.
If the cardinality of A is n, then
A is the disjoint union of {elements(i)} for 1 &lt;= i &lt;= n.
See <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_FOLD_UNION_DISJOINT">BAGS_FOLD_UNION_DISJOINT</a></code>.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> a bag argument A of type <code>(Bag T1)</code></li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> T1)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_FOLD_UNION_DISJOINT">BAGS_FOLD_UNION_DISJOINT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for bag.fold operator:
To compute <code>(bag.fold f t A)</code>, we need a function for
elements of A which is given by elements defined in
<code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_FOLD_ELEMENTS">BAGS_FOLD_ELEMENTS</a></code>.
We also need unionDisjoint: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> (Bag T1))</code> to compute
the disjoint union such that:
unionDisjoint(0) = bag.empty.
unionDisjoint(i) = disjoint union of {elements(i)} and unionDisjoint (i-1).
unionDisjoint(n) = A.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the bag argument A of type <code>(Bag T1)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> (Bag T1))</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_CHOOSE">BAGS_CHOOSE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An interpreted function <code>uf</code> for bag.choose operator:
<code>(bag.choose A)</code> is replaced by <code>(uf A)</code> along with the inference
that <code>(&gt;= (bag.count (uf A) A) 1)</code> when <code>A</code> is non-empty.
where <code>T</code> is the type of elements of A.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the bag to chose from, of type (Bag T).</li>
</ul>
</li>
<li>Sort: <code>(-&gt; (Bag T) T)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS">BAGS_DISTINCT_ELEMENTS : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for distinct elements of a bag A, which returns
the n^th distinct element of the bag.
See <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS_UNION_DISJOINT">BAGS_DISTINCT_ELEMENTS_UNION_DISJOINT</a></code>.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the bag argument A of type <code>(Bag T)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> T)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS_SIZE">BAGS_DISTINCT_ELEMENTS_SIZE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem variable for the size of the distinct elements of a bag A.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the bag argument A.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_MAP_PREIMAGE_INJECTIVE">BAGS_MAP_PREIMAGE_INJECTIVE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem for the preimage of an element y in <code>(bag.map f A)</code> such that
<code>(= (f x) y)</code> where f: <code>(-&gt; E T)</code> is an injective function.</p><ul>
<li>Number of skolem indices: <code>3</code><ul>
<li><code>1:</code> the function f of type <code>(-&gt; E T)</code>.</li>
<li><code>2:</code> the bag argument A of <code>(Bag E)</code>.</li>
<li><code>3:</code> the element argument y type <code>T</code>.</li>
</ul>
</li>
<li>Sort: <code>E</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_MAP_INDEX">BAGS_MAP_INDEX : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem variable for the index that is unique per terms
<code>(bag.map f A)</code>, y, e where:
f: <code>(-&gt; E T)</code>,
A: <code>(Bag E)</code>,
y: <code>T</code>,
e: <code>E</code></p><ul>
<li>Number of skolem indices: <code>5</code><ul>
<li><code>1:</code> a map term of the form <code>(bag.map f A)</code>.</li>
<li><code>2:</code> a skolem function with id <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS">BAGS_DISTINCT_ELEMENTS</a></code>.</li>
<li><code>3:</code> a skolem function with id <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS_SIZE">BAGS_DISTINCT_ELEMENTS_SIZE</a></code>.</li>
<li><code>4:</code> an element y of type <code>T</code> representing the mapped value.</li>
<li><code>5:</code> an element x of type <code>E</code>.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_MAP_SUM">BAGS_MAP_SUM : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for bag.map operator:
If bag A is {uf(1), ..., uf(n)} (see <code><a href=".././cvc5/SkolemId.html#cvc5.SkolemId.BAGS_DISTINCT_ELEMENTS">BAGS_DISTINCT_ELEMENTS</a></code>},
then the multiplicity of an element y in a bag <code>(bag.map f A)</code> is sum(n),
where sum: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code> is a skolem function such that:
sum(0) = 0
sum(i) = sum (i-1) + (bag.count (uf i) A)</p><ul>
<li>Number of skolem indices: <code>3</code><ul>
<li><code>1:</code> the function f of type <code>(-&gt; E T)</code>.</li>
<li><code>2:</code> the bag argument A of <code>(Bag E)</code>.</li>
<li><code>3:</code> the element argument e type <code>E</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> Int)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BAGS_DEQ_DIFF">BAGS_DEQ_DIFF : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The bag diff skolem, which is the witness k for the inference
<code>(=&gt; (not (= A B)) (not (= (bag.count k A) (bag.count k B))))</code>.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The first bag of type <code>(Bag T)</code>.</li>
<li><code>2:</code> The second bag of type <code>(Bag T)</code>.</li>
</ul>
</li>
<li>Sort: <code>T</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.TABLES_GROUP_PART">TABLES_GROUP_PART : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Given a group term <code>((_ table.group n1 ... nk) A)</code> of type
<code>(Bag (Table T))</code>, this skolem maps elements of A to their parts in the
resulting partition.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> a group term of the form <code>((_ table.group n1 ... nk) A)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; T (Table T))</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.TABLES_GROUP_PART_ELEMENT">TABLES_GROUP_PART_ELEMENT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Given a group term <code>((_ table.group n1 ... nk) A)</code> of type
<code>(Bag (Table T))</code> and a part B of type <code>(Table T)</code>, this function
returns a skolem element that is a member of B if B is not empty.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> a group term of the form <code>((_ table.group n1 ... nk) A)</code>.</li>
<li><code>2:</code> a table B of type <code>(Table T)</code>.</li>
</ul>
</li>
<li>Sort: <code>T</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.RELATIONS_GROUP_PART">RELATIONS_GROUP_PART : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Given a group term <code>((_ rel.group n1 ... nk) A)</code> of type
<code>(Set (Relation T))</code> this skolem maps elements of A to their parts in the
resulting partition.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> a relation of the form <code>((_ rel.group n1 ... nk) A)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; T (Relation T))</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.RELATIONS_GROUP_PART_ELEMENT">RELATIONS_GROUP_PART_ELEMENT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Given a group term ((_ rel.group n1 ... nk) A) of type (Set (Relation T))
and a part B of type (Relation T), this function returns a skolem element
that is a member of B if B is not empty.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> a group term of the form <code>((_ rel.group n1 ... nk) A)</code>.</li>
<li><code>2:</code> a relation B of type <code>(Relation T)</code>.</li>
</ul>
</li>
<li>Sort: <code>T</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SETS_CHOOSE">SETS_CHOOSE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An interpreted function for set.choose operator, where <code>(set.choose A)</code>
is expanded to <code>(uf A)</code> along with the inference
<code>(set.member (uf A) A))</code> when <code>A</code> is non-empty,
where uf: <code>(-&gt; (Set E) E)</code> is this skolem function, and E is the type of
elements of <code>A</code>.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> a ground value for the type <code>(Set E)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; (Set E) E)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SETS_DEQ_DIFF">SETS_DEQ_DIFF : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>The set diff skolem, which is the witness k for the inference
<code>(=&gt; (not (= A B)) (not (= (set.member k A) (set.member k B))))</code>.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The first set of type <code>(Set E)</code>.</li>
<li><code>2:</code> The second set of type <code>(Set E)</code>.</li>
</ul>
</li>
<li>Sort: <code>E</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SETS_FOLD_CARD">SETS_FOLD_CARD : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for set.fold operator:
To compute <code>(set.fold f t A)</code>, we need to guess the cardinality n of
set A using a skolem function with SETS_FOLD_CARD id.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the set argument A.</li>
</ul>
</li>
<li>Sort: <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SETS_FOLD_COMBINE">SETS_FOLD_COMBINE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for set.fold operator:
To compute <code>(set.fold f t A)</code>, we need a function that
accumulates intermidiate values. We call this function
combine of type Int -&gt; T2 where:
combine(0) = t
combine(i) = f(elements(i), combine(i - 1)) for 1 &lt;= i &lt;= n
elements: a skolem function for (set.fold f t A)
see SETS_FOLD_ELEMENTS
n: is the cardinality of A
T2: is the type of initial value t</p><ul>
<li>Number of skolem indices: <code>3</code><ul>
<li><code>1:</code> the function f of type <code>(-&gt; T1 T2)</code>.</li>
<li><code>2:</code> the initial value t of type <code>T2</code>.</li>
<li><code>3:</code> the set argument A of type <code>(Set T1)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> T2)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SETS_FOLD_ELEMENTS">SETS_FOLD_ELEMENTS : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for set.fold operator:
To compute <code>(set.fold f t A)</code>, we need a function for
elements of A. We call this function
elements of type <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> T)</code> where T is the type of
elements of A.
If the cardinality of A is n, then
A is the union of {elements(i)} for 1 &lt;= i &lt;= n.
See SETS_FOLD_UNION_DISJOINT.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> a set argument A of type <code>(Set T)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> T)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SETS_FOLD_UNION">SETS_FOLD_UNION : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>An uninterpreted function for set.fold operator:
To compute <code>(set.fold f t A)</code>, we need a function for
elements of A which is given by elements defined in
SETS_FOLD_ELEMENTS.
We also need unionFn: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> (Set E))</code> to compute
the union such that:
unionFn(0) = set.empty
unionFn(i) = union of {elements(i)} and unionFn (i-1)
unionFn(n) = A</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> a set argument A of type <code>(Set E)</code>.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; <a href=".././Init/Data/Int/Basic.html#Int">Int</a> (Set E))</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.SETS_MAP_DOWN_ELEMENT">SETS_MAP_DOWN_ELEMENT : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem variable that is unique per terms <code>(set.map f A)</code>, y which is an
element in <code>(set.map f A)</code>. The skolem is constrained to be an element in
A, and it is mapped to y by f.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> a map term of the form <code>(set.map f A)</code> where A of type <code>(Set E)</code></li>
<li><code>2:</code> the element argument y.</li>
</ul>
</li>
<li>Sort: <code>E</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.FP_MIN_ZERO">FP_MIN_ZERO : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem function that is unique per floating-point sort, introduced for
the undefined zero case of <code>fp.min</code>.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The floating-point sort <code>FP</code> of the fp.min operator.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; FP FP (_ <a href=".././Init/Prelude.html#BitVec">BitVec</a> 1))</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.FP_MAX_ZERO">FP_MAX_ZERO : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem function that is unique per floating-point sort, introduced for
the undefined zero case of <code>fp.max</code>.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The floating-point sort <code>FP</code> of the fp.max operator.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; FP FP (_ <a href=".././Init/Prelude.html#BitVec">BitVec</a> 1))</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.FP_TO_UBV">FP_TO_UBV : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem function introduced for the undefined out-ouf-bounds case of
<code>fp.to_ubv</code> that is unique per floating-point sort and sort of the
arguments to the operator.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The floating-point sort <code>FP</code> of operand of fp.to_ubv.</li>
<li><code>2:</code> The bit-vector sort <code>BV</code> to convert to.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; RoundingMode FP BV)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.FP_TO_SBV">FP_TO_SBV : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem function introduced for the undefined out-ouf-bounds case of
<code>fp.to_sbv</code> that is unique per floating-point sort and sort of the
arguments to the operator.</p><ul>
<li>Number of skolem indices: <code>2</code><ul>
<li><code>1:</code> The floating-point sort <code>FP</code> of operand of fp.to_sbv.</li>
<li><code>2:</code> The bit-vector sort <code>BV</code> to convert to.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; RoundingMode FP BV)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.FP_TO_REAL">FP_TO_REAL : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem function introduced for the undefined of <code>fp.to_real</code> that is
unique per floating-point sort.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> The floating-point sort <code>FP</code> of the operand of fp.to_real.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; FP Real)</code></li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.BV_TO_INT_UF">BV_TO_INT_UF : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>A skolem function introduced by the int-blaster.
Given a function f with argument and/or return types
that include bit-vectors, we get a function
that replaces them by integer types.
For example, if the original function is from
BV and Strings to Strings, the resulting
function is from Ints and Strings to Strings.</p><ul>
<li>Number of skolem indices: <code>1</code><ul>
<li><code>1:</code> the original function f, with BV sorts.</li>
</ul>
</li>
<li>Sort: <code>(-&gt; T1' ... ( -&gt; Tn' T')...)</code> Where
f has sort (-&gt;T1 ... (-&gt; Tn T)...) and Ti' (T') is
<code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code> if Ti (T) is <code>BV</code> and Ti' (T') is just Ti (T)
otherwise.</li>
</ul></div></li><li class="constructor" id="cvc5.SkolemId.NONE">NONE : <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a><div class="inductive_ctor_doc"><p>Indicates this is not a skolem.</p></div></li></ul><details id="instances-for-list-cvc5.SkolemId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="cvc5.instInhabitedSkolemId"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/SkolemId.lean#L781-L781">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/SkolemId.html#cvc5.instInhabitedSkolemId"><span class="name">cvc5</span>.<span class="name">instInhabitedSkolemId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/SkolemId.html#cvc5.instInhabitedSkolemId">cvc5.instInhabitedSkolemId</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././cvc5/SkolemId.html#cvc5.SkolemId.INTERNAL">cvc5.SkolemId.INTERNAL</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instReprSkolemId"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/SkolemId.lean#L781-L781">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/SkolemId.html#cvc5.instReprSkolemId"><span class="name">cvc5</span>.<span class="name">instReprSkolemId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Data/Repr.html#Repr">Repr</a> <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/SkolemId.html#cvc5.instReprSkolemId">cvc5.instReprSkolemId</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href=".././cvc5/SkolemId.html#cvc5.reprSkolemId._@.cvc5.SkolemId._hyg.18">cvc5.reprSkolemId</a> <a href=".././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instBEqSkolemId"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/SkolemId.lean#L781-L781">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/SkolemId.html#cvc5.instBEqSkolemId"><span class="name">cvc5</span>.<span class="name">instBEqSkolemId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/SkolemId.html#cvc5.instBEqSkolemId">cvc5.instBEqSkolemId</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href=".././cvc5/SkolemId.html#cvc5.beqSkolemId._@.cvc5.SkolemId._hyg.2118">cvc5.beqSkolemId</a> <a href=".././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instDecidableEqSkolemId"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/SkolemId.lean#L781-L781">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/SkolemId.html#cvc5.instDecidableEqSkolemId"><span class="name">cvc5</span>.<span class="name">instDecidableEqSkolemId</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././cvc5/SkolemId.html#cvc5.SkolemId">SkolemId</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././cvc5/SkolemId.html#cvc5.instDecidableEqSkolemId">cvc5.instDecidableEqSkolemId</a> <span class="fn">x</span> <span class="fn">y</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">x</span>.<a href=".././cvc5/SkolemId.html#cvc5.SkolemId.toCtorIdx">toCtorIdx</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y</span>.<a href=".././cvc5/SkolemId.html#cvc5.SkolemId.toCtorIdx">toCtorIdx</a></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn"></span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn"></span></span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>