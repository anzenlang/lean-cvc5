<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="icon" href=".././favicon.svg"></link><link rel="mask-icon" href=".././favicon.svg" color="#000000"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>cvc5.Kind</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="cvc5.Kind";</script><script type="module" src=".././jump-src.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././expand-nav.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">cvc5</span>.<span class="name">Kind</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href=".././Init.html">Init</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-cvc5.Kind" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#cvc5.Kind"><span class="name">cvc5</span>.<span class="name">Kind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instInhabitedKind"><span class="name">cvc5</span>.<span class="name">instInhabitedKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instReprKind"><span class="name">cvc5</span>.<span class="name">instReprKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instBEqKind"><span class="name">cvc5</span>.<span class="name">instBEqKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instDecidableEqKind"><span class="name">cvc5</span>.<span class="name">instDecidableEqKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.SortKind"><span class="name">cvc5</span>.<span class="name">SortKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instInhabitedSortKind"><span class="name">cvc5</span>.<span class="name">instInhabitedSortKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instReprSortKind"><span class="name">cvc5</span>.<span class="name">instReprSortKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instBEqSortKind"><span class="name">cvc5</span>.<span class="name">instBEqSortKind</span></a></div><div class="nav_link"><a class="break_within" href="#cvc5.instDecidableEqSortKind"><span class="name">cvc5</span>.<span class="name">instDecidableEqSortKind</span></a></div></nav><main>
<div class="decl" id="cvc5.Kind"><div class="inductive"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L10-L5840">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.Kind"><span class="name">cvc5</span>.<span class="name">Kind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The kind of a cvc5 Term.</p><p>\internal</p><p>Note that the API type <code>cvc5::Kind</code> roughly corresponds to
<code>cvc5::internal::Kind</code>, but is a different type. It hides internal kinds
that should not be exported to the API, and maps all kinds that we want to
export to its corresponding internal kinds. The underlying type of
<code>cvc5::Kind</code> must be signed (to enable range checks for validity). The size
of this type depends on the size of <code>cvc5::internal::Kind</code>
(<code>NodeValue::NBITS_KIND</code>, currently 10 bits, see expr/node_value.h).</p><ul class="constructors"><li class="constructor" id="cvc5.Kind.INTERNAL_KIND">INTERNAL_KIND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Internal kind.</p><p>This kind serves as an abstraction for internal kinds that are not exposed
via the API but may appear in terms returned by API functions, e.g.,
when querying the simplified form of a term.</p><p>\rst
.. note:: Should never be created via the API.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.UNDEFINED_KIND">UNDEFINED_KIND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Undefined kind.</p><p>\rst
.. note:: Should never be exposed or created via the API.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.NULL_TERM">NULL_TERM : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Null kind.</p><p>The kind of a null term (Term::Term()).</p><p>\rst
.. note:: May not be explicitly created via API functions other than
:cpp:func:<code>Term::Term()</code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.UNINTERPRETED_SORT_VALUE">UNINTERPRETED_SORT_VALUE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>The value of an uninterpreted constant.</p><p>\rst
.. note:: May be returned as the result of an API call, but terms of this
kind may not be created explicitly via the API and may not
appear in assertions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.EQUAL">EQUAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Equality, chainable.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of the same Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.DISTINCT">DISTINCT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Disequality.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of the same Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONSTANT">CONSTANT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Free constant symbol.</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkConst(const Sort&amp;, const std::string&amp;) const</li>
<li>Solver::mkConst(const Sort&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: Not permitted in bindings (e.g., :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.FORALL">FORALL</a></code>,
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.EXISTS">EXISTS</a></code>).
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.VARIABLE">VARIABLE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>(Bound) variable.</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkVar(const Sort&amp;, const std::string&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: Only permitted in bindings and in lambda and quantifier bodies.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SKOLEM">SKOLEM : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>A Skolem.</p><p>\rst
.. note:: Represents an internally generated term. Information on the
skolem is available via the calls <code>Solver::getSkolemId</code> and
<code>Solver::getSkolemIndices</code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SEXPR">SEXPR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Symbolic expression.</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
<ul>
<li><code>1..n:</code> Terms with same sorts</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.LAMBDA">LAMBDA : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Lambda expression.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST</a></code></p>
</li>
<li><p><code>2:</code> Term of any Sort (the body of the lambda)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.WITNESS">WITNESS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Witness.</p><p>The syntax of a witness term is similar to a quantified formula except that
only one variable is allowed.
For example, the term
\rst
.. code:: smtlib</p><pre><code>(witness ((x S)) F)
</code></pre><p>returns an element :math:<code>x</code> of Sort :math:<code>S</code> and asserts formula
:math:<code>F</code>.</p><p>The witness operator behaves like the description operator
(see <a href="https://planetmath.org/hilbertsvarepsilonoperator">https://planetmath.org/hilbertsvarepsilonoperator</a>) if there is
no :math:<code>x</code> that satisfies :math:<code>F</code>. But if such :math:<code>x</code> exists, the
witness operator does not enforce the following axiom which ensures
uniqueness up to logical equivalence:</p><p>.. math::</p><pre><code>\forall x. F \equiv G \Rightarrow witness~x. F =  witness~x. G
</code></pre><p>For example, if there are two elements of Sort :math:<code>S</code> that satisfy
formula :math:<code>F</code>, then the following formula is satisfiable:</p><p>.. code:: smtlib</p><pre><code>(distinct
   (witness ((x Int)) F)
   (witness ((x Int)) F))
</code></pre><p>\endrst</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST</a></code></li>
<li><code>2:</code> Term of Sort Bool (the body of the witness)</li>
<li><code>3:</code> (optional) Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST</a></code></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note::</p><pre><code>This kind is primarily used internally, but may be returned in
models (e.g., for arithmetic terms in non-linear queries). However,
it is not supported by the parser. Moreover, the user of the API
should be cautious when using this operator. In general, all witness
terms ``(witness ((x Int)) F)`` should be such that ``(exists ((x Int))
F)`` is a valid formula. If this is not the case, then the semantics
in formulas that use witness terms may be unintuitive. For example,
the following formula is unsatisfiable:
``(or (= (witness ((x Int)) false) 0) (not (= (witness ((x Int))
false) 0))``, whereas notice that ``(or (= z 0) (not (= z 0)))`` is
true for any :math:`z`.
</code></pre><p>\endrst</p></div></li><li class="constructor" id="cvc5.Kind.CONST_BOOLEAN">CONST_BOOLEAN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Boolean constant.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTrue() const</p>
</li>
<li><p>Solver::mkFalse() const</p>
</li>
<li><p>Solver::mkBoolean(bool) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.NOT">NOT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Logical negation.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Bool</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.AND">AND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Logical conjunction.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Bool</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.IMPLIES">IMPLIES : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Logical implication.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Bool</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.OR">OR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Logical disjunction.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Bool</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.XOR">XOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Logical exclusive disjunction, left associative.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Bool</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ITE">ITE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>If-then-else.</p><ul>
<li><p>Arity: <code>3</code></p>
</li>
<li><p><code>1:</code> Term of Sort Bool</p>
</li>
<li><p><code>2:</code> The 'then' term, Term of any Sort</p>
</li>
<li><p><code>3:</code> The 'else' term, Term of the same sort as second argument</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.APPLY_UF">APPLY_UF : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Application of an uninterpreted function.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1:</code> Function Term</p>
</li>
<li><p><code>2..n:</code> Function argument instantiation Terms of any first-class Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CARDINALITY_CONSTRAINT">CARDINALITY_CONSTRAINT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Cardinality constraint on uninterpreted sort.</p><p>\rst
Interpreted as a predicate that is true when the cardinality of
uinterpreted Sort :math:<code>S</code> is less than or equal to an upper bound.
\endrst</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkCardinalityConstraint(const Sort&amp;, uint32_t) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.HO_APPLY">HO_APPLY : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Higher-order applicative encoding of function application, left
associative.</p><ul>
<li><p>Arity: <code>n = 2</code></p>
<ul>
<li><code>1:</code> Function Term</li>
<li><code>2:</code> Argument Term of the domain Sort of the function</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ADD">ADD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arithmetic addition.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.MULT">MULT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arithmetic multiplication.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.IAND">IAND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Integer and.</p><p>\rst
Operator for bit-wise <code><a href=".././cvc5/Kind.html#cvc5.Kind.AND">AND</a></code> over integers, parameterized by a (positive)
bit-width :math:<code>k</code>.</p><p>.. code:: smtlib</p><pre><code>((_ iand k) i_1 i_2)
</code></pre><p>is equivalent to</p><p>.. code:: smtlib</p><pre><code>((_ iand k) i_1 i_2)
(bv2int (bvand ((_ int2bv k) i_1) ((_ int2bv k) i_2)))
</code></pre><p>for all integers <code>i_1</code>, <code>i_2</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of Sort Int</li>
</ul>
</li>
<li><p>Indices: <code>1</code></p>
<ul>
<li><code>1:</code> Bit-width :math:<code>k</code>
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.POW2">POW2 : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Power of two.</p><p>Operator for raising <code>2</code> to a non-negative integer power.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SUB">SUB : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arithmetic subtraction, left associative.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.NEG">NEG : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arithmetic negation.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int or Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.DIVISION">DIVISION : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Real division, division by 0 undefined, left associative.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.DIVISION_TOTAL">DIVISION_TOTAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Real division, division by 0 defined to be 0, left associative.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
<ul>
<li><code>1..n:</code> Terms of Sort Real</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.INTS_DIVISION">INTS_DIVISION : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Integer division, division by 0 undefined, left associative.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.INTS_DIVISION_TOTAL">INTS_DIVISION_TOTAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Integer division, division by 0 defined to be 0, left associative.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
<ul>
<li><code>1..n:</code> Terms of Sort Int</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.INTS_MODULUS">INTS_MODULUS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Integer modulus, modulus by 0 undefined.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int</p>
</li>
<li><p><code>2:</code> Term of Sort Int</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.INTS_MODULUS_TOTAL">INTS_MODULUS_TOTAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Integer modulus, t modulus by 0 defined to be t.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort Int</li>
<li><code>2:</code> Term of Sort Int</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.ABS">ABS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Absolute value.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int or Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.POW">POW : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arithmetic power.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Term of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.EXPONENTIAL">EXPONENTIAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Exponential function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SINE">SINE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sine function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.COSINE">COSINE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Cosine function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.TANGENT">TANGENT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Tangent function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.COSECANT">COSECANT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Cosecant function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SECANT">SECANT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Secant function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.COTANGENT">COTANGENT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Cotangent function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ARCSINE">ARCSINE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arc sine function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ARCCOSINE">ARCCOSINE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arc cosine function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ARCTANGENT">ARCTANGENT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arc tangent function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ARCCOSECANT">ARCCOSECANT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arc cosecant function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ARCSECANT">ARCSECANT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arc secant function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.ARCCOTANGENT">ARCCOTANGENT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arc cotangent function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SQRT">SQRT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Square root.</p><p>If the argument <code>x</code> is non-negative, then this returns a non-negative value
<code>y</code> such that <code>y * y = x</code>.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of Sort Real</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.DIVISIBLE">DIVISIBLE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>\rst
Operator for the divisibility-by-:math:<code>k</code> predicate.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of Sort Int</li>
</ul>
</li>
<li><p>Indices: <code>1</code></p>
<ul>
<li><code>1:</code> The integer :math:<code>k</code> to divide by.
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONST_RATIONAL">CONST_RATIONAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arbitrary-precision rational constant.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkReal(const std::string&amp;) const</p>
</li>
<li><p>Solver::mkReal(int64_t) const</p>
</li>
<li><p>Solver::mkReal(int64_t, int64_t) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONST_INTEGER">CONST_INTEGER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Arbitrary-precision integer constant.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkInteger(const std::string&amp;) const</p>
</li>
<li><p>Solver::mkInteger(int64_t) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.LT">LT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Less than, chainable.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.LEQ">LEQ : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Less than or equal, chainable.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.GT">GT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Greater than, chainable.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.GEQ">GEQ : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Greater than or equal, chainable.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort Int or Real (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.IS_INTEGER">IS_INTEGER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Is-integer predicate.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int or Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.TO_INTEGER">TO_INTEGER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Convert Term of sort Int or Real to Int via the floor function.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int or Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.TO_REAL">TO_REAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Convert Term of Sort Int or Real to Real.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int or Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.PI">PI : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Pi constant.</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkPi() const</li>
</ul>
</li>
</ul><p>\rst
.. note:: :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.PI">PI</a></code> is considered a special symbol of Sort
Real, but is not a Real value, i.e.,
:cpp:func:<code>Term::isRealValue()</code> will return <code>false</code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.CONST_BITVECTOR">CONST_BITVECTOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Fixed-size bit-vector constant.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkBitVector(uint32_t, uint64_t) const</p>
</li>
<li><p>Solver::mkBitVector(uint32_t, const std::string&amp;, uint32_t) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_CONCAT">BITVECTOR_CONCAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Concatenation of two or more bit-vectors.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_AND">BITVECTOR_AND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-wise and.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_OR">BITVECTOR_OR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-wise or.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_XOR">BITVECTOR_XOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-wise xor.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_NOT">BITVECTOR_NOT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-wise negation.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_NAND">BITVECTOR_NAND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-wise nand.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_NOR">BITVECTOR_NOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-wise nor.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_XNOR">BITVECTOR_XNOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-wise xnor, left associative.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_COMP">BITVECTOR_COMP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Equality comparison (returns bit-vector of size <code>1</code>).</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_MULT">BITVECTOR_MULT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Multiplication of two or more bit-vectors.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ADD">BITVECTOR_ADD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Addition of two or more bit-vectors.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SUB">BITVECTOR_SUB : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Subtraction of two bit-vectors.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_NEG">BITVECTOR_NEG : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Negation of a bit-vector (two's complement).</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_UDIV">BITVECTOR_UDIV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Unsigned bit-vector division.</p><p>Truncates towards <code>0</code>. If the divisor is zero, the result is all ones.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_UREM">BITVECTOR_UREM : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Unsigned bit-vector remainder.</p><p>Remainder from unsigned bit-vector division. If the modulus is zero, the
result is the dividend.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SDIV">BITVECTOR_SDIV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Signed bit-vector division.</p><p>Two's complement signed division of two bit-vectors. If the divisor is
zero and the dividend is positive, the result is all ones. If the divisor
is zero and the dividend is negative, the result is one.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SREM">BITVECTOR_SREM : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Signed bit-vector remainder (sign follows dividend).</p><p>Two's complement signed remainder of two bit-vectors where the sign
follows the dividend. If the modulus is zero, the result is the dividend.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SMOD">BITVECTOR_SMOD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Signed bit-vector remainder (sign follows divisor).</p><p>Two's complement signed remainder where the sign follows the divisor. If
the modulus is zero, the result is the dividend.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SHL">BITVECTOR_SHL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector shift left.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_LSHR">BITVECTOR_LSHR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector logical shift right.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ASHR">BITVECTOR_ASHR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector arithmetic shift right.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ULT">BITVECTOR_ULT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned less than.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ULE">BITVECTOR_ULE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned less than or equal.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_UGT">BITVECTOR_UGT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned greater than.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_UGE">BITVECTOR_UGE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned greater than or equal.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SLT">BITVECTOR_SLT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed less than.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SLE">BITVECTOR_SLE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed less than or equal.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SGT">BITVECTOR_SGT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed greater than.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SGE">BITVECTOR_SGE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed greater than or equal.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ULTBV">BITVECTOR_ULTBV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned less than returning a bit-vector of size 1.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SLTBV">BITVECTOR_SLTBV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed less than returning a bit-vector of size <code>1</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ITE">BITVECTOR_ITE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector if-then-else.</p><p>Same semantics as regular ITE, but condition is bit-vector of size <code>1</code>.</p><ul>
<li><p>Arity: <code>3</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort of size <code>1</code></p>
</li>
<li><p><code>1..3:</code> Terms of bit-vector sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_REDOR">BITVECTOR_REDOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector redor.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_REDAND">BITVECTOR_REDAND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector redand.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_NEGO">BITVECTOR_NEGO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector negation overflow detection.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_UADDO">BITVECTOR_UADDO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned addition overflow detection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SADDO">BITVECTOR_SADDO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed addition overflow detection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_UMULO">BITVECTOR_UMULO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned multiplication overflow detection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SMULO">BITVECTOR_SMULO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed multiplication overflow detection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_USUBO">BITVECTOR_USUBO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector unsigned subtraction overflow detection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SSUBO">BITVECTOR_SSUBO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed subtraction overflow detection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SDIVO">BITVECTOR_SDIVO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector signed division overflow detection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bit-vector Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_EXTRACT">BITVECTOR_EXTRACT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector extract.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>2</code></p>
</li>
<li><p><code>1:</code> The upper bit index.</p>
</li>
<li><p><code>2:</code> The lower bit index.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_REPEAT">BITVECTOR_REPEAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector repeat.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The number of times to repeat the given term.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ZERO_EXTEND">BITVECTOR_ZERO_EXTEND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector zero extension.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The number of zeroes to extend the given term with.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SIGN_EXTEND">BITVECTOR_SIGN_EXTEND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector sign extension.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The number of bits (of the value of the sign bit) to extend the given term with.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ROTATE_LEFT">BITVECTOR_ROTATE_LEFT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector rotate left.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The number of bits to rotate the given term left.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_ROTATE_RIGHT">BITVECTOR_ROTATE_RIGHT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector rotate right.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The number of bits to rotate the given term right.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.INT_TO_BITVECTOR">INT_TO_BITVECTOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion from Int to bit-vector.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The size of the bit-vector to convert to.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_TO_NAT">BITVECTOR_TO_NAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector conversion to (non-negative) integer.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of bit-vector Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note::  This kind is deprecated and replaced by
<code><a href=".././cvc5/Kind.html#cvc5.Kind.BITVECTOR_UBV_TO_INT">BITVECTOR_UBV_TO_INT</a></code>. It will be removed in a future
release.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_UBV_TO_INT">BITVECTOR_UBV_TO_INT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector conversion, unsigned bit-vector to integer.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_SBV_TO_INT">BITVECTOR_SBV_TO_INT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bit-vector conversion, signed bit-vector to integer.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_FROM_BOOLS">BITVECTOR_FROM_BOOLS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Converts a list of Bool terms to a bit-vector.</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
<ul>
<li><code>1..n:</code> Terms of Sort Bool</li>
</ul>
</li>
</ul><p>\rst
.. note:: May be returned as the result of an API call, but terms of this
kind may not be created explicitly via the API and may not
appear in assertions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BITVECTOR_BIT">BITVECTOR_BIT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Retrieves the bit at the given index from a bit-vector as a Bool term.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of bit-vector Sort</li>
</ul>
</li>
<li><p>Indices: <code>1</code></p>
<ul>
<li><code>1:</code> The bit index</li>
</ul>
</li>
</ul><p>\rst
.. note:: May be returned as the result of an API call, but terms of this
kind may not be created explicitly via the API and may not
appear in assertions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.CONST_FINITE_FIELD">CONST_FINITE_FIELD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Finite field constant.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkFiniteFieldElem(const std::string&amp;, const Sort&amp;, uint32_t base) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FINITE_FIELD_NEG">FINITE_FIELD_NEG : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Negation of a finite field element (additive inverse).</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of finite field Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FINITE_FIELD_ADD">FINITE_FIELD_ADD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Addition of two or more finite field elements.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of finite field Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FINITE_FIELD_BITSUM">FINITE_FIELD_BITSUM : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bitsum of two or more finite field elements: x + 2y + 4z + ...</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of finite field Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FINITE_FIELD_MULT">FINITE_FIELD_MULT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Multiplication of two or more finite field elements.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of finite field Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONST_FLOATINGPOINT">CONST_FLOATINGPOINT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point constant, created from IEEE-754 bit-vector representation
of the floating-point value.</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkFloatingPoint(uint32_t, uint32_t, Term) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONST_ROUNDINGMODE">CONST_ROUNDINGMODE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>RoundingMode constant.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkRoundingMode(RoundingMode) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_FP">FLOATINGPOINT_FP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Create floating-point literal from bit-vector triple.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of bit-vector Sort of size <code>1</code> (sign bit)</li>
<li><code>2:</code> Term of bit-vector Sort of exponent size (exponent)</li>
<li><code>3:</code> Term of bit-vector Sort of significand size - 1 (significand without hidden bit)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_EQ">FLOATINGPOINT_EQ : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point equality.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_ABS">FLOATINGPOINT_ABS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point absolute value.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_NEG">FLOATINGPOINT_NEG : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point negation.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_ADD">FLOATINGPOINT_ADD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point addition.</p><ul>
<li><p>Arity: <code>3</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2..3:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_SUB">FLOATINGPOINT_SUB : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point sutraction.</p><ul>
<li><p>Arity: <code>3</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2..3:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_MULT">FLOATINGPOINT_MULT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point multiply.</p><ul>
<li><p>Arity: <code>3</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2..3:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_DIV">FLOATINGPOINT_DIV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point division.</p><ul>
<li><p>Arity: <code>3</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2..3:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_FMA">FLOATINGPOINT_FMA : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point fused multiply and add.</p><ul>
<li><p>Arity: <code>4</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2..4:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_SQRT">FLOATINGPOINT_SQRT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point square root.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_REM">FLOATINGPOINT_REM : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point remainder.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_RTI">FLOATINGPOINT_RTI : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point round to integral.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_MIN">FLOATINGPOINT_MIN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point minimum.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_MAX">FLOATINGPOINT_MAX : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point maximum.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_LEQ">FLOATINGPOINT_LEQ : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point less than or equal.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_LT">FLOATINGPOINT_LT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point less than.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_GEQ">FLOATINGPOINT_GEQ : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point greater than or equal.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_GT">FLOATINGPOINT_GT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point greater than.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of floating-point Sort (sorts must match)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_IS_NORMAL">FLOATINGPOINT_IS_NORMAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point is normal tester.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_IS_SUBNORMAL">FLOATINGPOINT_IS_SUBNORMAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point is sub-normal tester.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_IS_ZERO">FLOATINGPOINT_IS_ZERO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point is zero tester.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_IS_INF">FLOATINGPOINT_IS_INF : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point is infinite tester.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_IS_NAN">FLOATINGPOINT_IS_NAN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point is NaN tester.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_IS_NEG">FLOATINGPOINT_IS_NEG : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point is negative tester.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_IS_POS">FLOATINGPOINT_IS_POS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Floating-point is positive tester.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of floating-point Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_IEEE_BV">FLOATINGPOINT_TO_FP_FROM_IEEE_BV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to floating-point from IEEE-754 bit-vector.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>2</code></p>
</li>
<li><p><code>1:</code> The exponent size</p>
</li>
<li><p><code>2:</code> The significand size</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_FP">FLOATINGPOINT_TO_FP_FROM_FP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to floating-point from floating-point.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of floating-point Sort</p>
</li>
<li><p>Indices: <code>2</code></p>
</li>
<li><p><code>1:</code> The exponent size</p>
</li>
<li><p><code>2:</code> The significand size</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_REAL">FLOATINGPOINT_TO_FP_FROM_REAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to floating-point from Real.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of Sort Real</p>
</li>
<li><p>Indices: <code>2</code></p>
</li>
<li><p><code>1:</code> The exponent size</p>
</li>
<li><p><code>2:</code> The significand size</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_SBV">FLOATINGPOINT_TO_FP_FROM_SBV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to floating-point from signed bit-vector.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>2</code></p>
</li>
<li><p><code>1:</code> The exponent size</p>
</li>
<li><p><code>2:</code> The significand size</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_UBV">FLOATINGPOINT_TO_FP_FROM_UBV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to floating-point from unsigned bit-vector.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of bit-vector Sort</p>
</li>
<li><p>Indices: <code>2</code></p>
</li>
<li><p><code>1:</code> The exponent size</p>
</li>
<li><p><code>2:</code> The significand size</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_UBV">FLOATINGPOINT_TO_UBV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to unsigned bit-vector from floating-point.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of floating-point Sort</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The size of the bit-vector to convert to.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_SBV">FLOATINGPOINT_TO_SBV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to signed bit-vector from floating-point.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort RoundingMode</p>
</li>
<li><p><code>2:</code> Term of floating-point Sort</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The size of the bit-vector to convert to.</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FLOATINGPOINT_TO_REAL">FLOATINGPOINT_TO_REAL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion to Real from floating-point.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Real</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SELECT">SELECT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Array select.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of array Sort</p>
</li>
<li><p><code>2:</code> Term of array index Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STORE">STORE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Array store.</p><ul>
<li><p>Arity: <code>3</code></p>
</li>
<li><p><code>1:</code> Term of array Sort</p>
</li>
<li><p><code>2:</code> Term of array index Sort</p>
</li>
<li><p><code>3:</code> Term of array element Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONST_ARRAY">CONST_ARRAY : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Constant array.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of array Sort</p>
</li>
<li><p><code>2:</code> Term of array element Sort (value)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.EQ_RANGE">EQ_RANGE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>\rst
Equality over arrays :math:<code>a</code> and :math:<code>b</code> over a given range
:math:<code>[i,j]</code>, i.e.,</p><p>.. math::</p><p>\forall k . i \leq k \leq j \Rightarrow a[k] = b[k]</p><p>\endrst</p><ul>
<li><p>Arity: <code>4</code></p>
<ul>
<li><code>1:</code> Term of array Sort (first array)</li>
<li><code>2:</code> Term of array Sort (second array)</li>
<li><code>3:</code> Term of array index Sort (lower bound of range, inclusive)</li>
<li><code>4:</code> Term of array index Sort (upper bound of range, inclusive)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.</p><p>.. note:: We currently support the creation of array equalities over index
Sorts bit-vector, floating-point, Int and Real.
Requires to enable option
:ref:<code>arrays-exp&lt;lbl-option-arrays-exp&gt;</code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.APPLY_CONSTRUCTOR">APPLY_CONSTRUCTOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Datatype constructor application.</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
</li>
<li><p><code>1:</code> DatatypeConstructor Term (see DatatypeConstructor::getTerm() const)</p>
</li>
<li><p><code>2..n:</code> Terms of the Sorts of the selectors of the constructor (the arguments to the constructor)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.APPLY_SELECTOR">APPLY_SELECTOR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Datatype selector application.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> DatatypeSelector Term (see DatatypeSelector::getTerm() const)</li>
<li><code>2:</code> Term of the codomain Sort of the selector</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: Undefined if misapplied.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.APPLY_TESTER">APPLY_TESTER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Datatype tester application.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Datatype tester Term (see DatatypeConstructor::getTesterTerm() const)</p>
</li>
<li><p><code>2:</code> Term of Datatype Sort (DatatypeConstructor must belong to this Datatype Sort)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.APPLY_UPDATER">APPLY_UPDATER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Datatype update application.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Datatype updater Term (see DatatypeSelector::getUpdaterTerm() const)</li>
<li><code>2:</code> Term of Datatype Sort (DatatypeSelector of the updater must belong to a constructor of this Datatype Sort)</li>
<li><code>3:</code> Term of the codomain Sort of the selector (the Term to update the field of the datatype term with)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: Does not change the datatype argument if misapplied.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.MATCH">MATCH : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Match expression.</p><p>This kind is primarily used in the parser to support the
SMT-LIBv2 <code>match</code> expression.</p><p>For example, the SMT-LIBv2 syntax for the following match term
\rst
.. code:: smtlib</p><pre><code> (match l (((cons h t) h) (nil 0)))
</code></pre><p>is represented by the AST</p><p>.. code:: lisp</p><pre><code>(MATCH l
    (MATCH_BIND_CASE (VARIABLE_LIST h t) (cons h t) h)
    (MATCH_CASE nil 0))
</code></pre><p>Terms of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.MATCH_CASE">MATCH_CASE</a></code> are constant case expressions,
which are used for nullary constructors. Kind
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.MATCH_BIND_CASE">MATCH_BIND_CASE</a></code> is used for constructors with selectors
and variable match patterns. If not all constructors are covered, at least
one catch-all variable pattern must be included.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
<ul>
<li><code>1..n:</code> Terms of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.MATCH_CASE">MATCH_CASE</a></code> and :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.MATCH_BIND_CASE">MATCH_BIND_CASE</a></code>
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.MATCH_CASE">MATCH_CASE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Match case for nullary constructors.</p><p>A (constant) case expression to be used within a match expression.</p><p>\rst</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.APPLY_CONSTRUCTOR">APPLY_CONSTRUCTOR</a></code> (the pattern to match against)</li>
<li><code>2:</code> Term of any Sort (the term the match term evaluates to)</li>
</ul>
</li>
</ul><p>\endrst</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.MATCH_BIND_CASE">MATCH_BIND_CASE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Match case with binders, for constructors with selectors and variable
patterns.</p><p>A (non-constant) case expression to be used within a match expression.</p><p>\rst</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><p>For variable patterns:</p>
<ul>
<li><code>1:</code> Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST</a></code> (containing the free variable of the case)</li>
<li><code>2:</code> Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE">VARIABLE</a></code> (the pattern expression, the free variable of the case)</li>
<li><code>3:</code> Term of any Sort (the term the pattern evaluates to)</li>
</ul>
</li>
<li><p>For constructors with selectors:</p>
<ul>
<li><code>1:</code> Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST</a></code> (containing the free variable of the case)</li>
<li><code>2:</code> Term of kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.APPLY_CONSTRUCTOR">APPLY_CONSTRUCTOR</a></code> (the pattern expression, applying the set of variables to the constructor)</li>
<li><code>3:</code> Term of any Sort (the term the match term evaluates to)
\endrst</li>
</ul>
</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.TUPLE_PROJECT">TUPLE_PROJECT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Tuple projection.</p><p>This operator takes a tuple as an argument and returns a tuple obtained by
concatenating components of its argument at the provided indices.</p><p>For example,
\rst
.. code:: smtlib</p><pre><code>((_ tuple.project 1 2 2 3 1) (tuple 10 20 30 40))
</code></pre><p>\endrst
yields
\rst
.. code:: smtlib</p><pre><code>(tuple 20 30 30 40 20)
</code></pre><p>\endrst</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of tuple Sort</li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code> The tuple indices to project</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.NULLABLE_LIFT">NULLABLE_LIFT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Lifting operator for nullable terms.
This operator lifts a built-in operator or a user-defined function
to nullable terms.
For built-in kinds use mkNullableLift.
For user-defined functions use mkTerm.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of nullable sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkNullableLift(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEP_NIL">SEP_NIL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Separation logic nil.</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkSepNil(const Sort&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SEP_EMP">SEP_EMP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Separation logic empty heap.</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkSepEmp() const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SEP_PTO">SEP_PTO : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Separation logic points-to relation.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term denoting the location of the points-to constraint</li>
<li><code>2:</code> Term denoting the data of the points-to constraint</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SEP_STAR">SEP_STAR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Separation logic star.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
<ul>
<li><code>1..n:</code> Terms of sort Bool (the child constraints that hold in
disjoint (separated) heaps)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SEP_WAND">SEP_WAND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Separation logic magic wand.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Terms of Sort Bool (the antecendant of the magic wand constraint)</li>
<li><code>2:</code> Terms of Sort Bool (conclusion of the magic wand constraint,
which is asserted to hold in all heaps that are disjoint
extensions of the antecedent)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_EMPTY">SET_EMPTY : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Empty set.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkEmptySet(const Sort&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_UNION">SET_UNION : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set union.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_INTER">SET_INTER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set intersection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_MINUS">SET_MINUS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set subtraction.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_SUBSET">SET_SUBSET : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Subset predicate.</p><p>Determines if the first set is a subset of the second set.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_MEMBER">SET_MEMBER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set membership predicate.</p><p>Determines if the given set element is a member of the second set.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of any Sort (must match the element Sort of the given set Term)</p>
</li>
<li><p><code>2:</code> Term of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_SINGLETON">SET_SINGLETON : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Singleton set.</p><p>Construct a singleton set from an element given as a parameter.
The returned set has the same Sort as the element.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of any Sort (the set element)</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_INSERT">SET_INSERT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>The set obtained by inserting elements;</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
</li>
<li><p><code>1..n-1:</code> Terms of any Sort (must match the element sort of the given set Term)</p>
</li>
<li><p><code>n:</code> Term of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_CARD">SET_CARD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set cardinality.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_COMPLEMENT">SET_COMPLEMENT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set complement with respect to finite universe.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of set Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SET_UNIVERSE">SET_UNIVERSE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Finite universe set.</p><p>All set variables must be interpreted as subsets of it.</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkUniverseSet(const Sort&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.SET_UNIVERSE">SET_UNIVERSE</a></code> is considered a special symbol of
the theory of sets and is not considered as a set value, i.e.,
Term::isSetValue() will return <code>false</code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_COMPREHENSION">SET_COMPREHENSION : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set comprehension</p><p>\rst
A set comprehension is specified by a variable list :math:<code>x_1 ... x_n</code>,
a predicate :math:<code>P[x_1...x_n]</code>, and a term :math:<code>t[x_1...x_n]</code>. A
comprehension :math:<code>C</code> with the above form has members given by the
following semantics:</p><p>.. math::</p><p>\forall y. ( \exists x_1...x_n. P[x_1...x_n] \wedge t[x_1...x_n] = y )
\Leftrightarrow (set.member ; y ; C)</p><p>where :math:<code>y</code> ranges over the element Sort of the (set) Sort of the
comprehension. If :math:<code>t[x_1..x_n]</code> is not provided, it is equivalent
to :math:<code>y</code> in the above formula.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST</a></code></li>
<li><code>2:</code> Term of sort Bool (the predicate of the comprehension)</li>
<li><code>3:</code> (optional) Term denoting the generator for the comprehension
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_CHOOSE">SET_CHOOSE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set choose.</p><p>\rst
Select an element from a given set. For a set :math:<code>A = \{x\}</code>, the term
(set.choose :math:<code>A</code>) is equivalent to the term :math:<code>x_1</code>. For an empty
set, it is an arbitrary value. For a set with cardinality &gt; 1, it will
deterministically return an element in :math:<code>A</code>.
\endrst</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of set Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_IS_EMPTY">SET_IS_EMPTY : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set is empty tester.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of set Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_IS_SINGLETON">SET_IS_SINGLETON : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set is singleton tester.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of set Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_MAP">SET_MAP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set map.</p><p>\rst
This operator applies the first argument, a function of
Sort :math:<code>(\rightarrow S_1 \; S_2)</code>, to every element of the second
argument, a set of Sort (Set :math:<code>S_1</code>), and returns a set of Sort
(Set :math:<code>S_2</code>).</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow S_1 \; S_2)</code></li>
<li><code>2:</code> Term of set Sort (Set :math:<code>S_1</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_FILTER">SET_FILTER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set filter.</p><p>\rst
This operator filters the elements of a set.
(set.filter :math:<code>p \; A</code>) takes a predicate :math:<code>p</code> of Sort
:math:<code>(\rightarrow T \; Bool)</code> as a first argument, and a set :math:<code>A</code>
of Sort (Set :math:<code>T</code>) as a second argument, and returns a subset of Sort
(Set :math:<code>T</code>) that includes all elements of :math:<code>A</code> that satisfy
:math:<code>p</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow T \; Bool)</code></li>
<li><code>2:</code> Term of bag Sort (Set :math:<code>T</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_ALL">SET_ALL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set all.</p><p>\rst
This operator checks whether all elements of a set satisfy a predicate.
(set.all :math:<code>p \; A</code>) takes a predicate :math:<code>p</code> of Sort
:math:<code>(\rightarrow T \; Bool)</code> as a first argument, and a set :math:<code>A</code>
of Sort (Set :math:<code>T</code>) as a second argument, and returns true iff all
elements of :math:<code>A</code> satisfy predicate :math:<code>p</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow T \; Bool)</code></li>
<li><code>2:</code> Term of set Sort (Set :math:<code>T</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_SOME">SET_SOME : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set some.</p><p>\rst
This operator checks whether at least one element of a set satisfies a predicate.
(set.some :math:<code>p \; A</code>) takes a predicate :math:<code>p</code> of Sort
:math:<code>(\rightarrow T \; Bool)</code> as a first argument, and a set :math:<code>A</code>
of Sort (Set :math:<code>T</code>) as a second argument, and returns true iff at least<br></br>
one element of :math:<code>A</code> satisfies predicate :math:<code>p</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow T \; Bool)</code></li>
<li><code>2:</code> Term of set Sort (Set :math:<code>T</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SET_FOLD">SET_FOLD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Set fold.</p><p>\rst
This operator combines elements of a set into a single value.
(set.fold :math:<code>f \; t \; A</code>) folds the elements of set :math:<code>A</code>
starting with Term :math:<code>t</code> and using the combining function :math:<code>f</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow S_1 \; S_2 \; S_2)</code></li>
<li><code>2:</code> Term of Sort :math:<code>S_2</code> (the initial value)</li>
<li><code>3:</code> Term of bag Sort (Set :math:<code>S_1</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.RELATION_JOIN">RELATION_JOIN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation join.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of relation Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.RELATION_TABLE_JOIN">RELATION_TABLE_JOIN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>\rst
Table join operator for relations has the form
:math:<code>((\_ \; rel.table\_join \; m_1 \; n_1 \; \dots \; m_k \; n_k) \; A \; B)</code>
where :math:<code>m_1 \; n_1 \; \dots \; m_k \; n_k</code> are natural numbers,
and :math:<code>A, B</code> are relations.
This operator filters the product of two sets based on the equality of
projected tuples using indices :math:<code>m_1, \dots, m_k</code> in relation :math:<code>A</code>,
and indices :math:<code>n_1, \dots, n_k</code> in relation :math:<code>B</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><p><code>1:</code> Term of relation Sort</p>
</li>
<li><p><code>2:</code> Term of relation Sort</p>
</li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code>  Indices of the projection</li>
</ul>
</li>
</ul><p>\endrst</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.RELATION_PRODUCT">RELATION_PRODUCT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation cartesian product.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of relation Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.RELATION_TRANSPOSE">RELATION_TRANSPOSE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation transpose.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of relation Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.RELATION_TCLOSURE">RELATION_TCLOSURE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation transitive closure.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of relation Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.RELATION_JOIN_IMAGE">RELATION_JOIN_IMAGE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation join image.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of relation Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.RELATION_IDEN">RELATION_IDEN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation identity.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of relation Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.RELATION_GROUP">RELATION_GROUP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation group</p><p>\rst
:math:<code>((\_ \; rel.group \; n_1 \; \dots \; n_k) \; A)</code> partitions tuples
of relation :math:<code>A</code> such that tuples that have the same projection
with indices :math:<code>n_1 \; \dots \; n_k</code> are in the same part.
It returns a set of relations of type :math:<code>(Set \; T)</code> where
:math:<code>T</code> is the type of :math:<code>A</code>.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of relation sort</li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code>  Indices of the projection</li>
</ul>
</li>
</ul><p>\endrst</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.RELATION_AGGREGATE">RELATION_AGGREGATE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>\rst</p><p>Relation aggregate operator has the form
:math:<code>((\_ \; rel.aggr \; n_1 ... n_k) \; f \; i \; A)</code>
where :math:<code>n_1, ..., n_k</code> are natural numbers,
:math:<code>f</code> is a function of type
:math:<code>(\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)</code>,
:math:<code>i</code> has the type :math:<code>T</code>,
and :math:<code>A</code> has type :math:<code>(Relation \;  T_1 \; ... \; T_j)</code>.
The returned type is :math:<code>(Set \; T)</code>.</p><p>This operator aggregates elements in A that have the same tuple projection
with indices n_1, ..., n_k using the combining function :math:<code>f</code>,
and initial value :math:<code>i</code>.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of sort :math:<code>(\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)</code></li>
<li><code>2:</code> Term of Sort :math:<code>T</code></li>
<li><code>3:</code> Term of relation sort :math:<code>Relation T_1 ... T_j</code></li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code> Indices of the projection
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.RELATION_PROJECT">RELATION_PROJECT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Relation projection operator extends tuple projection operator to sets.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of relation Sort</li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code> Indices of the projection</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const
\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_EMPTY">BAG_EMPTY : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Empty bag.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkEmptyBag(const Sort&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_UNION_MAX">BAG_UNION_MAX : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag max union.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bag Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_UNION_DISJOINT">BAG_UNION_DISJOINT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag disjoint union (sum).</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bag Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_INTER_MIN">BAG_INTER_MIN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag intersection (min).</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bag Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_DIFFERENCE_SUBTRACT">BAG_DIFFERENCE_SUBTRACT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag difference subtract.</p><p>Subtracts multiplicities of the second from the first.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bag Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_DIFFERENCE_REMOVE">BAG_DIFFERENCE_REMOVE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag difference remove.</p><p>Removes shared elements in the two bags.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of bag Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_SUBBAG">BAG_SUBBAG : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag inclusion predicate.</p><p>Determine if multiplicities of the first bag are less than or equal to
multiplicities of the second bag.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of bag Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_COUNT">BAG_COUNT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag element multiplicity.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const Term&amp;, const Term&amp;) const</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_MEMBER">BAG_MEMBER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag membership predicate.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of any Sort (must match the element Sort of the given bag Term)</p>
</li>
<li><p><code>2:</code> Terms of bag Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_SETOF">BAG_SETOF : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag setof.</p><p>Eliminate duplicates in a given bag. The returned bag contains exactly the
same elements in the given bag, but with multiplicity one.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of bag Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_MAKE">BAG_MAKE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag make.</p><p>Construct a bag with the given element and given multiplicity.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of any Sort (the bag element)</p>
</li>
<li><p><code>2:</code> Term of Sort Int (the multiplicity of the element)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.BAG_CARD">BAG_CARD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag cardinality.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of bag Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_CHOOSE">BAG_CHOOSE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag choose.</p><p>Select an element from a given bag.</p><p>\rst
For a bag :math:<code>A = \{(x,n)\}</code> where :math:<code>n</code> is the multiplicity, then
the term (choose :math:<code>A</code>) is equivalent to the term :math:<code>x</code>. For an
empty bag, then it is an arbitrary value. For a bag that contains distinct
elements, it will deterministically return an element in :math:<code>A</code>.
\endrst</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of bag Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_MAP">BAG_MAP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag map.</p><p>\rst
This operator applies the first argument, a function of
Sort :math:<code>(\rightarrow S_1 \; S_2)</code>, to every element of the second
argument, a set of Sort (Bag :math:<code>S_1</code>), and returns a set of Sort
(Bag :math:<code>S_2</code>).</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow S_1 \; S_2)</code></li>
<li><code>2:</code> Term of bag Sort (Bag :math:<code>S_1</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_FILTER">BAG_FILTER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag filter.</p><p>\rst
This operator filters the elements of a bag.
(bag.filter :math:<code>p \; B</code>) takes a predicate :math:<code>p</code> of Sort
:math:<code>(\rightarrow T \; Bool)</code> as a first argument, and a bag :math:<code>B</code>
of Sort (Bag :math:<code>T</code>) as a second argument, and returns a subbag of Sort
(Bag :math:<code>T</code>) that includes all elements of :math:<code>B</code> that satisfy
:math:<code>p</code> with the same multiplicity.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow T \; Bool)</code></li>
<li><code>2:</code> Term of bag Sort (Bag :math:<code>T</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_ALL">BAG_ALL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag all.</p><p>\rst
This operator checks whether all elements of a bag satisfy a predicate.
(bag.all :math:<code>p \; A</code>) takes a predicate :math:<code>p</code> of Sort
:math:<code>(\rightarrow T \; Bool)</code> as a first argument, and a bag :math:<code>A</code>
of Sort (Bag :math:<code>T</code>) as a second argument, and returns true iff all
elements of :math:<code>A</code> satisfy predicate :math:<code>p</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow T \; Bool)</code></li>
<li><code>2:</code> Term of bag Sort (Bag :math:<code>T</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_SOME">BAG_SOME : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag some.</p><p>\rst
This operator checks whether at least one element of a bag satisfies a predicate.
(bag.some :math:<code>p \; A</code>) takes a predicate :math:<code>p</code> of Sort
:math:<code>(\rightarrow T \; Bool)</code> as a first argument, and a bag :math:<code>A</code>
of Sort (Bag :math:<code>T</code>) as a second argument, and returns true iff at least<br></br>
one element of :math:<code>A</code> satisfies predicate :math:<code>p</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow T \; Bool)</code></li>
<li><code>2:</code> Term of bag Sort (Bag :math:<code>T</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_FOLD">BAG_FOLD : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag fold.</p><p>\rst
This operator combines elements of a bag into a single value.
(bag.fold :math:<code>f \; t \; B</code>) folds the elements of bag :math:<code>B</code>
starting with Term :math:<code>t</code> and using the combining function :math:<code>f</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow S_1 \; S_2 \; S_2)</code></li>
<li><code>2:</code> Term of Sort :math:<code>S_2</code> (the initial value)</li>
<li><code>3:</code> Term of bag Sort (Bag :math:<code>S_1</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.BAG_PARTITION">BAG_PARTITION : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Bag partition.</p><p>\rst
This operator partitions of a bag of elements into disjoint bags.
(bag.partition :math:<code>r \; B</code>) partitions the elements of bag :math:<code>B</code>
of type :math:<code>(Bag \; E)</code> based on the equivalence relations :math:<code>r</code> of
type :math:<code>(\rightarrow \; E \; E \; Bool)</code>.
It returns a bag of bags of type :math:<code>(Bag \; (Bag \; E))</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of function Sort :math:<code>(\rightarrow \; E \; E \; Bool)</code></li>
<li><code>2:</code> Term of bag Sort (Bag :math:<code>E</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.TABLE_PRODUCT">TABLE_PRODUCT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Table cross product.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1..2:</code> Terms of table Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.TABLE_PROJECT">TABLE_PROJECT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Table projection operator extends tuple projection operator to tables.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of table Sort</li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code> Indices of the projection</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const
\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.TABLE_AGGREGATE">TABLE_AGGREGATE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>\rst</p><p>Table aggregate operator has the form
:math:<code>((\_ \; table.aggr \; n_1 ... n_k) \; f \; i \; A)</code>
where :math:<code>n_1, ..., n_k</code> are natural numbers,
:math:<code>f</code> is a function of type
:math:<code>(\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)</code>,
:math:<code>i</code> has the type :math:<code>T</code>,
and :math:<code>A</code> has type :math:<code>(Table \;  T_1 \; ... \; T_j)</code>.
The returned type is :math:<code>(Bag \; T)</code>.</p><p>This operator aggregates elements in A that have the same tuple projection
with indices n_1, ..., n_k using the combining function :math:<code>f</code>,
and initial value :math:<code>i</code>.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of sort :math:<code>(\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)</code></li>
<li><code>2:</code> Term of Sort :math:<code>T</code></li>
<li><code>3:</code> Term of table sort :math:<code>Table T_1 ... T_j</code></li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code> Indices of the projection
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.TABLE_JOIN">TABLE_JOIN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>\rst
Table join operator has the form
:math:<code>((\_ \; table.join \; m_1 \; n_1 \; \dots \; m_k \; n_k) \; A \; B)</code>
where :math:<code>m_1 \; n_1 \; \dots \; m_k \; n_k</code> are natural numbers,
and :math:<code>A, B</code> are tables.
This operator filters the product of two bags based on the equality of
projected tuples using indices :math:<code>m_1, \dots, m_k</code> in table :math:<code>A</code>,
and indices :math:<code>n_1, \dots, n_k</code> in table :math:<code>B</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><p><code>1:</code> Term of table Sort</p>
</li>
<li><p><code>2:</code> Term of table Sort</p>
</li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code>  Indices of the projection</li>
</ul>
</li>
</ul><p>\endrst</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.TABLE_GROUP">TABLE_GROUP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Table group</p><p>\rst
:math:<code>((\_ \; table.group \; n_1 \; \dots \; n_k) \; A)</code> partitions tuples
of table :math:<code>A</code> such that tuples that have the same projection
with indices :math:<code>n_1 \; \dots \; n_k</code> are in the same part.
It returns a bag of tables of type :math:<code>(Bag \; T)</code> where
:math:<code>T</code> is the type of :math:<code>A</code>.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of table sort</li>
</ul>
</li>
<li><p>Indices: <code>n</code></p>
<ul>
<li><code>1..n:</code>  Indices of the projection</li>
</ul>
</li>
</ul><p>\endrst</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.STRING_CONCAT">STRING_CONCAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String concat.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of Sort String</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_IN_REGEXP">STRING_IN_REGEXP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String membership.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort String</p>
</li>
<li><p><code>2:</code> Term of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_LENGTH">STRING_LENGTH : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String length.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort String</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_SUBSTR">STRING_SUBSTR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String substring.</p><p>\rst
Extracts a substring, starting at index :math:<code>i</code> and of length :math:<code>l</code>,
from a string :math:<code>s</code>.  If the start index is negative, the start index
is greater than the length of the string, or the length is negative, the
result is the empty string.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Sort String</li>
<li><code>2:</code> Term of Sort Int (index :math:<code>i</code>)</li>
<li><code>3:</code> Term of Sort Int (length :math:<code>l</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_UPDATE">STRING_UPDATE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String update.</p><p>\rst
Updates a string :math:<code>s</code> by replacing its context starting at an index
with string :math:<code>t</code>. If the start index is negative, the start index is
greater than the length of the string, the result is :math:<code>s</code>. Otherwise,
the length of the original string is preserved.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Sort String</li>
<li><code>2:</code> Term of Sort Int (index :math:<code>i</code>)</li>
<li><code>3:</code> Term of Sort Strong (replacement string :math:<code>t</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_CHARAT">STRING_CHARAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String character at.</p><p>\rst
Returns the character at index :math:<code>i</code> from a string :math:<code>s</code>. If the
index is negative or the index is greater than the length of the string,
the result is the empty string. Otherwise the result is a string of
length 1.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort String (string :math:<code>s</code>)</li>
<li><code>2:</code> Term of Sort Int (index :math:<code>i</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_CONTAINS">STRING_CONTAINS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String contains.</p><p>\rst
Determines whether a string :math:<code>s_1</code> contains another string
:math:<code>s_2</code>. If :math:<code>s_2</code> is empty, the result is always <code>true</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort String (the string :math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (the string :math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_INDEXOF">STRING_INDEXOF : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String index-of.</p><p>\rst
Returns the index of a substring :math:<code>s_2</code> in a string :math:<code>s_1</code>
starting at index :math:<code>i</code>. If the index is negative or greater than the
length of string :math:<code>s_1</code> or the substring :math:<code>s_2</code> does not appear
in string :math:<code>s_1</code> after index :math:<code>i</code>, the result is -1.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort String (substring :math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (substring :math:<code>s_2</code>)</li>
<li><code>3:</code> Term of Sort Int (index :math:<code>i</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_INDEXOF_RE">STRING_INDEXOF_RE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String index-of regular expression match.</p><p>\rst
Returns the first match of a regular expression :math:<code>r</code> in a
string :math:<code>s</code>. If the index is negative or greater than the length of
string :math:<code>s_1</code>, or :math:<code>r</code> does not match a substring in :math:<code>s</code>
after index :math:<code>i</code>, the result is -1.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Sort String (string :math:<code>s</code>)</li>
<li><code>2:</code> Term of Sort RegLan (regular expression :math:<code>r</code>)</li>
<li><code>3:</code> Term of Sort Int (index :math:<code>i</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_REPLACE">STRING_REPLACE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String replace.</p><p>\rst
Replaces a string :math:<code>s_2</code> in a string :math:<code>s_1</code> with string
:math:<code>s_3</code>. If :math:<code>s_2</code> does not appear in :math:<code>s_1</code>, :math:<code>s_1</code> is
returned unmodified.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Sort String (string :math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (string :math:<code>s_2</code>)</li>
<li><code>3:</code> Term of Sort String (string :math:<code>s_3</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_REPLACE_ALL">STRING_REPLACE_ALL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String replace all.</p><p>\rst
Replaces all occurrences of a string :math:<code>s_2</code> in a string :math:<code>s_1</code>
with string :math:<code>s_3</code>. If :math:<code>s_2</code> does not appear in :math:<code>s_1</code>,
:math:<code>s_1</code> is returned unmodified.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Sort String (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (:math:<code>s_2</code>)</li>
<li><code>3:</code> Term of Sort String (:math:<code>s_3</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_REPLACE_RE">STRING_REPLACE_RE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String replace regular expression match.</p><p>\rst
Replaces the first match of a regular expression :math:<code>r</code> in
string :math:<code>s_1</code> with string :math:<code>s_2</code>. If :math:<code>r</code> does not match a
substring of :math:<code>s_1</code>, :math:<code>s_1</code> is returned unmodified.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Sort String (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort RegLan</li>
<li><code>3:</code> Term of Sort String (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_REPLACE_RE_ALL">STRING_REPLACE_RE_ALL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String replace all regular expression matches.</p><p>\rst
Replaces all matches of a regular expression :math:<code>r</code> in string
:math:<code>s_1</code> with string :math:<code>s_2</code>. If :math:<code>r</code> does not match a
substring of :math:<code>s_1</code>, string :math:<code>s_1</code> is returned unmodified.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Sort String (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort RegLan</li>
<li><code>3:</code> Term of Sort String (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_TO_LOWER">STRING_TO_LOWER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String to lower case.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort String</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_TO_UPPER">STRING_TO_UPPER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String to upper case.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort String</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_REV">STRING_REV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String reverse.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort String</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_TO_CODE">STRING_TO_CODE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String to code.</p><p>Returns the code point of a string if it has length one, or returns <code>-1</code>
otherwise.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of Sort String</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_FROM_CODE">STRING_FROM_CODE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String from code.</p><p>Returns a string containing a single character whose code point matches
the argument to this function, or the empty string if the argument is
out-of-bounds.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of Sort Int</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_LT">STRING_LT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String less than.</p><p>\rst
Returns true if string :math:<code>s_1</code> is (strictly) less than :math:<code>s_2</code>
based on a lexiographic ordering over code points.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort String (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_LEQ">STRING_LEQ : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String less than or equal.</p><p>\rst
Returns true if string :math:<code>s_1</code> is less than or equal to :math:<code>s_2</code>
based on a lexiographic ordering over code points.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort String (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_PREFIX">STRING_PREFIX : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String prefix-of.</p><p>\rst
Determines whether a string :math:<code>s_1</code> is a prefix of string :math:<code>s_2</code>.
If string s1 is empty, this operator returns <code>true</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort String (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_SUFFIX">STRING_SUFFIX : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String suffix-of.</p><p>\rst
Determines whether a string :math:<code>s_1</code> is a suffix of the second string.
If string :math:<code>s_1</code> is empty, this operator returns <code>true</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of Sort String (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of Sort String (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_IS_DIGIT">STRING_IS_DIGIT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String is-digit.</p><p>Returns true if given string is a digit (it is one of <code>&quot;0&quot;</code>, ...,
<code>&quot;9&quot;</code>).</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of Sort String</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_FROM_INT">STRING_FROM_INT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion from Int to String.</p><p>If the integer is negative this operator returns the empty string.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort Int</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_TO_INT">STRING_TO_INT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>String to integer (total function).</p><p>If the string does not contain an integer or the integer is negative, the
operator returns <code>-1</code>.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of Sort Int</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONST_STRING">CONST_STRING : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Constant string.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkString(const std::string&amp;, bool) const</p>
</li>
<li><p>Solver::mkString(const std::wstring&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.STRING_TO_REGEXP">STRING_TO_REGEXP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Conversion from string to regexp.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort String</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_CONCAT">REGEXP_CONCAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression concatenation.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_UNION">REGEXP_UNION : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression union.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_INTER">REGEXP_INTER : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression intersection.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_DIFF">REGEXP_DIFF : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression difference.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1..2:</code> Terms of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_STAR">REGEXP_STAR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression *.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_PLUS">REGEXP_PLUS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression +.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_OPT">REGEXP_OPT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression ?.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_RANGE">REGEXP_RANGE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression range.</p><ul>
<li><p>Arity: <code>2</code></p>
</li>
<li><p><code>1:</code> Term of Sort String (lower bound character for the range)</p>
</li>
<li><p><code>2:</code> Term of Sort String (upper bound character for the range)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_REPEAT">REGEXP_REPEAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Operator for regular expression repeat.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort RegLan</p>
</li>
<li><p>Indices: <code>1</code></p>
</li>
<li><p><code>1:</code> The number of repetitions</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_LOOP">REGEXP_LOOP : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression loop.</p><p>Regular expression loop from lower bound to upper bound number of
repetitions.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of Sort RegLan</li>
</ul>
</li>
<li><p>Indices: <code>1</code></p>
<ul>
<li><code>1:</code> The lower bound</li>
<li><code>2:</code> The upper bound</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_NONE">REGEXP_NONE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression none.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkRegexpNone() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_ALL">REGEXP_ALL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression all.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkRegexpAll() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_ALLCHAR">REGEXP_ALLCHAR : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression all characters.</p><ul>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkRegexpAllchar() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.REGEXP_COMPLEMENT">REGEXP_COMPLEMENT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Regular expression complement.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of Sort RegLan</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_CONCAT">SEQ_CONCAT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence concat.</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
</li>
<li><p><code>1..n:</code> Terms of sequence Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_LENGTH">SEQ_LENGTH : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence length.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of sequence Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_EXTRACT">SEQ_EXTRACT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence extract.</p><p>\rst
Extracts a subsequence, starting at index :math:<code>i</code> and of length :math:<code>l</code>,
from a sequence :math:<code>s</code>.  If the start index is negative, the start index
is greater than the length of the sequence, or the length is negative, the
result is the empty sequence.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort</li>
<li><code>2:</code> Term of Sort Int (index :math:<code>i</code>)</li>
<li><code>3:</code> Term of Sort Int (length :math:<code>l</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_UPDATE">SEQ_UPDATE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence update.</p><p>\rst
Updates a sequence :math:<code>s</code> by replacing its context starting at an index
with string :math:<code>t</code>. If the start index is negative, the start index is
greater than the length of the sequence, the result is :math:<code>s</code>.
Otherwise, the length of the original sequence is preserved.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort</li>
<li><code>2:</code> Term of Sort Int (index :math:<code>i</code>)</li>
<li><code>3:</code> Term of sequence Sort (replacement sequence :math:<code>t</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_AT">SEQ_AT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence element at.</p><p>\rst
Returns the element at index :math:<code>i</code> from a sequence :math:<code>s</code>. If the index
is negative or the index is greater or equal to the length of the
sequence, the result is the empty sequence. Otherwise the result is a
sequence of length <code>1</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort</li>
<li><code>2:</code> Term of Sort Int (index :math:<code>i</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_CONTAINS">SEQ_CONTAINS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence contains.</p><p>\rst
Checks whether a sequence :math:<code>s_1</code> contains another sequence
:math:<code>s_2</code>. If :math:<code>s_2</code> is empty, the result is always <code>true</code>.</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of sequence Sort (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_INDEXOF">SEQ_INDEXOF : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence index-of.</p><p>\rst
Returns the index of a subsequence :math:<code>s_2</code> in a sequence :math:<code>s_1</code>
starting at index :math:<code>i</code>. If the index is negative or greater than the
length of sequence :math:<code>s_1</code> or the subsequence :math:<code>s_2</code> does not
appear in sequence :math:<code>s_1</code> after index :math:<code>i</code>, the result is -1.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of sequence Sort (:math:<code>s_2</code>)</li>
<li><code>3:</code> Term of Sort Int (:math:<code>i</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_REPLACE">SEQ_REPLACE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence replace.</p><p>\rst
Replaces the first occurrence of a sequence :math:<code>s_2</code> in a
sequence :math:<code>s_1</code> with sequence :math:<code>s_3</code>. If :math:<code>s_2</code> does not
appear in :math:<code>s_1</code>, :math:<code>s_1</code> is returned unmodified.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of sequence Sort (:math:<code>s_2</code>)</li>
<li><code>3:</code> Term of sequence Sort (:math:<code>s_3</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_REPLACE_ALL">SEQ_REPLACE_ALL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence replace all.</p><p>\rst
Replaces all occurrences of a sequence :math:<code>s_2</code> in a sequence
:math:<code>s_1</code> with sequence :math:<code>s_3</code>. If :math:<code>s_2</code> does not appear in
:math:<code>s_1</code>, sequence :math:<code>s_1</code> is returned unmodified.</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of sequence Sort (:math:<code>s_2</code>)</li>
<li><code>3:</code> Term of sequence Sort (:math:<code>s_3</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_REV">SEQ_REV : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence reverse.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of sequence Sort</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_PREFIX">SEQ_PREFIX : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence prefix-of.</p><p>\rst
Checks whether a sequence :math:<code>s_1</code> is a prefix of sequence :math:<code>s_2</code>.
If sequence :math:<code>s_1</code> is empty, this operator returns <code>true</code>.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of sequence Sort (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_SUFFIX">SEQ_SUFFIX : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence suffix-of.</p><p>\rst
Checks whether a sequence :math:<code>s_1</code> is a suffix of sequence :math:<code>s_2</code>.
If sequence :math:<code>s_1</code> is empty, this operator returns <code>true</code>.</p><ul>
<li><p>Arity: <code>1</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort (:math:<code>s_1</code>)</li>
<li><code>2:</code> Term of sequence Sort (:math:<code>s_2</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.CONST_SEQUENCE">CONST_SEQUENCE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Constant sequence.</p><p>A constant sequence is a term that is equivalent to:
\rst
.. code:: smtlib</p><pre><code>(seq.++ (seq.unit c1) ... (seq.unit cn))
</code></pre><p>where :math:<code>n \leq 0</code> and :math:<code>c_1, ..., c_n</code> are constants of some
sort. The elements can be extracted with Term::getSequenceValue().
\endrst</p><ul>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkEmptySequence(const Sort&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_UNIT">SEQ_UNIT : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence unit.</p><p>Corresponds to a sequence of length one with the given term.</p><ul>
<li><p>Arity: <code>1</code></p>
</li>
<li><p><code>1:</code> Term of any Sort (the element term)</p>
</li>
<li><p>Create Term of this Kind with:</p>
</li>
<li><p>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</p>
</li>
<li><p>Create Op of this kind with:</p>
</li>
<li><p>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.SEQ_NTH">SEQ_NTH : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Sequence nth.</p><p>Corresponds to the nth element of a sequence.</p><p>\rst</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> Term of sequence Sort</li>
<li><code>2:</code> Term of Sort Int (:math:<code>n</code>)
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.FORALL">FORALL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Universally quantified formula.</p><p>\rst</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST</a></code></li>
<li><code>2:</code> Term of Sort Bool (the quantifier body)</li>
<li><code>3:</code> (optional) Term of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN">INST_PATTERN</a></code>
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.EXISTS">EXISTS : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Existentially quantified formula.</p><p>\rst</p><ul>
<li><p>Arity: <code>3</code></p>
<ul>
<li><code>1:</code> Term of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST</a></code></li>
<li><code>2:</code> Term of Sort Bool (the quantifier body)</li>
<li><code>3:</code> (optional) Term of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN">INST_PATTERN</a></code>
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.VARIABLE_LIST">VARIABLE_LIST : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Variable list.</p><p>A list of variables (used to bind variables under a quantifier)</p><p>\rst</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
<ul>
<li><code>1..n:</code> Terms of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.VARIABLE">VARIABLE</a></code>
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.INST_PATTERN">INST_PATTERN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Instantiation pattern.</p><p>Specifies a (list of) terms to be used as a pattern for quantifier
instantiation.</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
<ul>
<li><code>1..n:</code> Terms of any Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: Should only be used as a child of
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST</a></code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.INST_NO_PATTERN">INST_NO_PATTERN : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Instantiation no-pattern.</p><p>Specifies a (list of) terms that should not be used as a pattern for
quantifier instantiation.</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
<ul>
<li><code>1..n:</code> Terms of any Sort</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: Should only be used as a child of
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST</a></code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.INST_POOL">INST_POOL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Instantiation pool annotation.</p><p>Specifies an annotation for pool based instantiation.</p><p>In detail, pool symbols can be declared via the method</p><ul>
<li>Solver::declarePool(const std::string&amp;, const Sort&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul><p>A pool symbol represents a set of terms of a given sort. An instantiation
pool annotation should either:
(1) have child sets matching the types of the quantified formula,
(2) have a child set of tuple type whose component types match the types
of the quantified formula.</p><p>For an example of (1), for a quantified formula:</p><p>\rst
.. code:: lisp</p><pre><code>(FORALL (VARIABLE_LIST x y) F (INST_PATTERN_LIST (INST_POOL p q)))
</code></pre><p>if :math:<code>x</code> and :math:<code>y</code> have Sorts :math:<code>S_1</code> and :math:<code>S_2</code>, then
pool symbols :math:<code>p</code> and :math:<code>q</code> should have Sorts (Set :math:<code>S_1</code>)
and (Set :math:<code>S_2</code>), respectively. This annotation specifies that the
quantified formula above should be instantiated with the product of all
terms that occur in the sets :math:<code>p</code> and :math:<code>q</code>.
\endrst</p><p>Alternatively, as an example of (2), for a quantified formula:</p><p>\rst
.. code:: lisp</p><pre><code>(FORALL (VARIABLE_LIST x y) F (INST_PATTERN_LIST (INST_POOL s)))
</code></pre><p>:math:<code>s</code> should have Sort (Set (Tuple :math:<code>S_1</code> :math:<code>S_2</code>)). This
annotation specifies that the quantified formula above should be
instantiated with the pairs of values in :math:<code>s</code>.</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
<ul>
<li><code>1..n:</code> Terms that comprise the pools, which are one-to-one with the variables of the quantified formula to be instantiated</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>.. warning:: This kind is experimental and may be changed or removed in
future versions.</p><p>.. note:: Should only be used as a child of
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST</a></code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.INST_ADD_TO_POOL">INST_ADD_TO_POOL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>A instantantiation-add-to-pool annotation.</p><p>An instantantiation-add-to-pool annotation indicates that when a quantified
formula is instantiated, the instantiated version of a term should be
added to the given pool.</p><p>For example, consider a quantified formula:</p><p>\rst
.. code:: lisp</p><pre><code>(FORALL (VARIABLE_LIST x) F
        (INST_PATTERN_LIST (INST_ADD_TO_POOL (ADD x 1) p)))
</code></pre><p>where assume that :math:<code>x</code> has type Int. When this quantified formula is
instantiated with, e.g., the term :math:<code>t</code>, the term <code>(ADD t 1)</code> is
added to pool :math:<code>p</code>.
\endrst</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> The Term whose free variables are bound by the quantified formula.</li>
<li><code>2:</code> The pool to add to, whose Sort should be a set of elements that match the Sort of the first argument.</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.</p><p>.. note:: Should only be used as a child of
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST</a></code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.SKOLEM_ADD_TO_POOL">SKOLEM_ADD_TO_POOL : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>A skolemization-add-to-pool annotation.</p><p>An skolemization-add-to-pool annotation indicates that when a quantified
formula is skolemized, the skolemized version of a term should be added to
the given pool.</p><p>For example, consider a quantified formula:</p><p>\rst
.. code:: lisp</p><pre><code>(FORALL (VARIABLE_LIST x) F
        (INST_PATTERN_LIST (SKOLEM_ADD_TO_POOL (ADD x 1) p)))
</code></pre><p>where assume that :math:<code>x</code> has type Int. When this quantified formula is
skolemized, e.g., with :math:<code>k</code> of type Int, then the term <code>(ADD k 1)</code>
is added to the pool :math:<code>p</code>.
\endrst</p><ul>
<li><p>Arity: <code>2</code></p>
<ul>
<li><code>1:</code> The Term whose free variables are bound by the quantified formula.</li>
<li><code>2:</code> The pool to add to, whose Sort should be a set of elements that match the Sort of the first argument.</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. warning:: This kind is experimental and may be changed or removed in
future versions.</p><p>.. note:: Should only be used as a child of
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST</a></code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.INST_ATTRIBUTE">INST_ATTRIBUTE : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Instantiation attribute.</p><p>Specifies a custom property for a quantified formula given by a
term that is ascribed a user attribute.</p><ul>
<li><p>Arity: <code>n &gt; 0</code></p>
<ul>
<li><code>1:</code> Term of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.CONST_STRING">CONST_STRING</a></code> (the keyword of the attribute)</li>
<li><code>2...n:</code> Terms representing the values of the attribute</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul><p>\rst
.. note:: Should only be used as a child of
:cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST</a></code>.
\endrst</p></div></li><li class="constructor" id="cvc5.Kind.INST_PATTERN_LIST">INST_PATTERN_LIST : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>A list of instantiation patterns, attributes or annotations.</p><p>\rst</p><ul>
<li><p>Arity: <code>n &gt; 1</code></p>
<ul>
<li><code>1..n:</code> Terms of Kind :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_PATTERN">INST_PATTERN</a></code>, :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_NO_PATTERN">INST_NO_PATTERN</a></code>, :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_POOL">INST_POOL</a></code>, :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_ADD_TO_POOL">INST_ADD_TO_POOL</a></code>, :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.SKOLEM_ADD_TO_POOL">SKOLEM_ADD_TO_POOL</a></code>, :cpp:enumerator:<code><a href=".././cvc5/Kind.html#cvc5.Kind.INST_ATTRIBUTE">INST_ATTRIBUTE</a></code>
\endrst</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li>Solver::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;) const</li>
<li>Solver::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;) const</li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li>Solver::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.Kind.LAST_KIND">LAST_KIND : <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a><div class="inductive_ctor_doc"><p>Marks the upper-bound of this enumeration.</p></div></li></ul><details id="instances-for-list-cvc5.Kind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="cvc5.instInhabitedKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L5840-L5840">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instInhabitedKind"><span class="name">cvc5</span>.<span class="name">instInhabitedKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/Kind.html#cvc5.instInhabitedKind">cvc5.instInhabitedKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././cvc5/Kind.html#cvc5.Kind.INTERNAL_KIND">cvc5.Kind.INTERNAL_KIND</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instReprKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L5840-L5840">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instReprKind"><span class="name">cvc5</span>.<span class="name">instReprKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Data/Repr.html#Repr">Repr</a> <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/Kind.html#cvc5.instReprKind">cvc5.instReprKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href=".././cvc5/Kind.html#cvc5.reprKind._@.cvc5.Kind._hyg.18">cvc5.reprKind✝</a> <a href=".././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instBEqKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L5840-L5840">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instBEqKind"><span class="name">cvc5</span>.<span class="name">instBEqKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/Kind.html#cvc5.instBEqKind">cvc5.instBEqKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href=".././cvc5/Kind.html#cvc5.beqKind._@.cvc5.Kind._hyg.9478">cvc5.beqKind✝</a> <a href=".././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instDecidableEqKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L5840-L5840">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instDecidableEqKind"><span class="name">cvc5</span>.<span class="name">instDecidableEqKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././cvc5/Kind.html#cvc5.Kind">Kind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././cvc5/Kind.html#cvc5.instDecidableEqKind">cvc5.instDecidableEqKind</a> <span class="fn">x✝</span> <span class="fn">y✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">x✝</span>.<a href=".././cvc5/Kind.html#cvc5.Kind.toCtorIdx">toCtorIdx</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y✝</span>.<a href=".././cvc5/Kind.html#cvc5.Kind.toCtorIdx">toCtorIdx</a></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div><div class="decl" id="cvc5.SortKind"><div class="inductive"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L5842-L6053">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.SortKind"><span class="name">cvc5</span>.<span class="name">SortKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././foundational_types.html">Type</a></div></div><p>The kind of a cvc5 Sort.</p><p>\internal</p><p>Note that the API type <code>cvc5::SortKind</code> roughly corresponds to
<code>cvc5::internal::Kind</code>, but is a different type. It hides internal kinds
that should not be exported to the API, and maps all kinds that we want to
export to its corresponding internal kinds. The underlying type of
<code>cvc5::Kind</code> must be signed (to enable range checks for validity). The size
of this type depends on the size of <code>cvc5::internal::Kind</code>
(<code>NodeValue::NBITS_KIND</code>, currently 10 bits, see expr/node_value.h).</p><ul class="constructors"><li class="constructor" id="cvc5.SortKind.INTERNAL_SORT_KIND">INTERNAL_SORT_KIND : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>Internal kind.</p><p>This kind serves as an abstraction for internal kinds that are not exposed
via the API but may appear in terms returned by API functions, e.g.,
when querying the simplified form of a term.</p><p>\rst
.. note:: Should never be created via the API.
\endrst</p></div></li><li class="constructor" id="cvc5.SortKind.UNDEFINED_SORT_KIND">UNDEFINED_SORT_KIND : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>Undefined kind.</p><p>\rst
.. note:: Should never be exposed or created via the API.
\endrst</p></div></li><li class="constructor" id="cvc5.SortKind.NULL_SORT">NULL_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>Null kind.</p><p>The kind of a null sort (Sort::Sort()).</p><p>\rst
.. note:: May not be explicitly created via API functions other than
:cpp:func:<code>Sort::Sort()</code>.
\endrst</p></div></li><li class="constructor" id="cvc5.SortKind.ABSTRACT_SORT">ABSTRACT_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>An abstract sort.</p><p>An abstract sort represents a sort whose parameters or argument sorts are
unspecified. For example, <code>mkAbstractSort(BITVECTOR_SORT)</code> returns a
sort that represents the sort of bit-vectors whose bit-width is
unspecified.</p><ul>
<li><p>Create Sort of this Kind with:</p>
<ul>
<li>Solver::mkAbstractSort(SortKind) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.ARRAY_SORT">ARRAY_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>An array sort, whose argument sorts are the index and element sorts of the
array.</p><ul>
<li><p>Create Sort of this Kind with:</p>
<ul>
<li>Solver::mkArraySort(Sort, Sort) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.BAG_SORT">BAG_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A bag sort, whose argument sort is the element sort of the bag.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkBagSort(Sort) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.BOOLEAN_SORT">BOOLEAN_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>The Boolean sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::getBooleanSort() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.BITVECTOR_SORT">BITVECTOR_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A bit-vector sort, parameterized by an integer denoting its bit-width.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkBitVectorSort(uint32_t) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.DATATYPE_SORT">DATATYPE_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A datatype sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkDatatypeSort(DatatypeDecl)</p>
</li>
<li><p>Solver::mkDatatypeSorts(const std::vector&lt;DatatypeDecl&gt;&amp;)</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.FINITE_FIELD_SORT">FINITE_FIELD_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A finite field sort, parameterized by a size.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkFiniteFieldSort(const std::string&amp;, uint32_t base) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.FLOATINGPOINT_SORT">FLOATINGPOINT_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A floating-point sort, parameterized by two integers denoting its
exponent and significand bit-widths.</p><ul>
<li><p>Create Sort of this Kind with:</p>
<ul>
<li>Solver::mkFloatingPointSort(uint32_t, uint32_t) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.FUNCTION_SORT">FUNCTION_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A function sort with given domain sorts and codomain sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkFunctionSort(const std::vector&lt;Sort&gt;&amp;, Sort) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.INTEGER_SORT">INTEGER_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>The integer sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::getIntegerSort() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.REAL_SORT">REAL_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>The real sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::getRealSort() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.REGLAN_SORT">REGLAN_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>The regular language sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::getRegExpSort() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.ROUNDINGMODE_SORT">ROUNDINGMODE_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>The rounding mode sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::getRoundingModeSort() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.SEQUENCE_SORT">SEQUENCE_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A sequence sort, whose argument sort is the element sort of the sequence.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkSequenceSort(Sort) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.SET_SORT">SET_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A set sort, whose argument sort is the element sort of the set.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkSetSort(Sort) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.STRING_SORT">STRING_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>The string sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::getStringSort() const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.TUPLE_SORT">TUPLE_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A tuple sort, whose argument sorts denote the sorts of the direct children
of the tuple.</p><ul>
<li><p>Create Sort of this Kind with:</p>
<ul>
<li>Solver::mkTupleSort(const std::vector&lt;Sort&gt;&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.NULLABLE_SORT">NULLABLE_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>A nullable sort, whose argument sort denotes the sort of the direct child
of the nullable.</p><ul>
<li><p>Create Sort of this Kind with:</p>
<ul>
<li>Solver::mkNullableSort(const Sort&amp;) const</li>
</ul>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.UNINTERPRETED_SORT">UNINTERPRETED_SORT : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>An uninterpreted sort.</p><ul>
<li><p>Create Sort of this Kind with:</p>
</li>
<li><p>Solver::mkUninterpretedSort(const std::optional<a href=".././std::string">std::string</a>&amp;) const</p>
</li>
</ul></div></li><li class="constructor" id="cvc5.SortKind.LAST_SORT_KIND">LAST_SORT_KIND : <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a><div class="inductive_ctor_doc"><p>Marks the upper-bound of this enumeration.</p></div></li></ul><details id="instances-for-list-cvc5.SortKind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="cvc5.instInhabitedSortKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L6053-L6053">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instInhabitedSortKind"><span class="name">cvc5</span>.<span class="name">instInhabitedSortKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/Kind.html#cvc5.instInhabitedSortKind">cvc5.instInhabitedSortKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <a href=".././cvc5/Kind.html#cvc5.SortKind.INTERNAL_SORT_KIND">cvc5.SortKind.INTERNAL_SORT_KIND</a> <a href=".././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instReprSortKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L6053-L6053">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instReprSortKind"><span class="name">cvc5</span>.<span class="name">instReprSortKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Data/Repr.html#Repr">Repr</a> <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/Kind.html#cvc5.instReprSortKind">cvc5.instReprSortKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href=".././cvc5/Kind.html#cvc5.reprSortKind._@.cvc5.Kind._hyg.9608">cvc5.reprSortKind✝</a> <a href=".././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instBEqSortKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L6053-L6053">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instBEqSortKind"><span class="name">cvc5</span>.<span class="name">instBEqSortKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href=".././cvc5/Kind.html#cvc5.instBEqSortKind">cvc5.instBEqSortKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#BEq.mk">{</a> <span class="fn">beq</span> := <a href=".././cvc5/Kind.html#cvc5.beqSortKind._@.cvc5.Kind._hyg.10364">cvc5.beqSortKind✝</a> <a href=".././Init/Prelude.html#BEq.mk">}</a></li></ul></details></div></div><div class="decl" id="cvc5.instDecidableEqSortKind"><div class="instance"><div class="gh_link"><a href="https://github.com/anzenlang/lean-cvc5/blob/09e0846752e4ec8b64108cba52d92801f9643efa/cvc5/Kind.lean#L6053-L6053">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././cvc5/Kind.html#cvc5.instDecidableEqSortKind"><span class="name">cvc5</span>.<span class="name">instDecidableEqSortKind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././cvc5/Kind.html#cvc5.SortKind">SortKind</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././cvc5/Kind.html#cvc5.instDecidableEqSortKind">cvc5.instDecidableEqSortKind</a> <span class="fn">x✝</span> <span class="fn">y✝</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">x✝</span>.<a href=".././cvc5/Kind.html#cvc5.SortKind.toCtorIdx">toCtorIdx</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">y✝</span>.<a href=".././cvc5/Kind.html#cvc5.SortKind.toCtorIdx">toCtorIdx</a></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">⋯</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">⋯</span></span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src=".././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>